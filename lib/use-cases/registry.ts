import { createEmptyToolSpec, type IntegrationId, type ToolSystemSpec } from "@/lib/toolos/spec";
import { getCapabilitiesForIntegration } from "@/lib/capabilities/registry";

export type UseCaseCategory =
  | "Featured"
  | "Engineering"
  | "Design"
  | "Marketing"
  | "Sales"
  | "Operations"
  | "Leadership / Exec"
  | "Personal (Consumer)";

export type UseCaseTrigger = "Prompt-based" | "Event-based" | "Time-based";
export type UseCaseOutput = "Table" | "Summary" | "Alert" | "Document";

export type UseCaseDefinition = {
  id: string;
  name: string;
  description: string;
  category: UseCaseCategory;
  integrations: IntegrationId[];
  trigger: UseCaseTrigger;
  output: UseCaseOutput;
  prompt: string;
  spec: ToolSystemSpec;
};

const integrationCapabilities = (id: IntegrationId) =>
  getCapabilitiesForIntegration(id).map((cap) => cap.id);

const buildSpec = (input: {
  id: string;
  name: string;
  description: string;
  purpose: string;
  integrations: IntegrationId[];
  entities: ToolSystemSpec["entities"];
  actions: ToolSystemSpec["actions"];
  views: ToolSystemSpec["views"];
  query_plans: ToolSystemSpec["query_plans"];
  answer_contract: ToolSystemSpec["answer_contract"];
  goal_plan: ToolSystemSpec["goal_plan"];
  intent_contract: ToolSystemSpec["intent_contract"];
  triggers?: ToolSystemSpec["triggers"];
  initialFetch?: ToolSystemSpec["initialFetch"];
  dataReadiness?: ToolSystemSpec["dataReadiness"];
}) => {
  const base = createEmptyToolSpec({
    id: input.id,
    name: input.name,
    purpose: input.purpose,
    description: input.description,
    sourcePrompt: input.purpose,
  });

  return {
    ...base,
    integrations: input.integrations.map((id) => ({
      id,
      capabilities: integrationCapabilities(id),
    })),
    entities: input.entities,
    actions: input.actions,
    views: input.views,
    triggers: input.triggers ?? [],
    query_plans: input.query_plans,
    answer_contract: input.answer_contract,
    goal_plan: input.goal_plan,
    intent_contract: input.intent_contract,
    initialFetch: input.initialFetch,
    dataReadiness: input.dataReadiness,
    automations: {
      enabled: true,
      capabilities: {
        canRunWithoutUI: true,
        supportedTriggers: (input.triggers ?? []).map((t) => t.type),
        maxFrequency: 1440,
        safetyConstraints: ["approval_required_for_writes"],
      },
    },
    observability: {
      executionTimeline: true,
      recentRuns: true,
      errorStates: true,
      integrationHealth: true,
      manualRetryControls: true,
    },
  };
};

const buildIntentContract = (input: {
  userGoal: string;
  integrations: string[];
  objects?: string[];
  filters?: string[];
  successCriteria?: string[];
  forbiddenOutputs?: string[];
}) => ({
  userGoal: input.userGoal,
  successCriteria: input.successCriteria ?? [],
  implicitConstraints: [],
  hiddenStateRequirements: [],
  subjectivityScore: 0.35,
  heuristics: [],
  requiredEntities: {
    integrations: input.integrations,
    objects: input.objects ?? [],
    filters: input.filters ?? [],
  },
  forbiddenOutputs: input.forbiddenOutputs ?? [],
  acceptableFallbacks: [],
});

const emailEntity = {
  name: "Email",
  sourceIntegration: "google" as const,
  identifiers: ["id", "threadId"],
  supportedActions: ["google.gmail.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "from", type: "string" },
    { name: "subject", type: "string" },
    { name: "snippet", type: "string" },
    { name: "internalDate", type: "string" },
    { name: "labelIds", type: "array" },
  ],
};

const slackMessageEntity = {
  name: "Message",
  sourceIntegration: "slack" as const,
  identifiers: ["id", "timestamp"],
  supportedActions: ["slack.messages.search", "slack.messages.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "channel", type: "string" },
    { name: "user", type: "string" },
    { name: "text", type: "string" },
    { name: "timestamp", type: "string" },
  ],
};

const githubIssueEntity = {
  name: "Issue",
  sourceIntegration: "github" as const,
  identifiers: ["id", "number"],
  supportedActions: ["github.issues.search", "github.issues.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "number", type: "number" },
    { name: "title", type: "string" },
    { name: "state", type: "string" },
    { name: "url", type: "string" },
  ],
};

const linearIssueEntity = {
  name: "Issue",
  sourceIntegration: "linear" as const,
  identifiers: ["id"],
  supportedActions: ["linear.issues.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "title", type: "string" },
    { name: "state", type: "string" },
    { name: "assignee", type: "string" },
    { name: "priority", type: "number" },
  ],
};

const notionPageEntity = {
  name: "Page",
  sourceIntegration: "notion" as const,
  identifiers: ["id"],
  supportedActions: ["notion.pages.search"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "title", type: "string" },
    { name: "lastEdited", type: "string" },
    { name: "url", type: "string" },
  ],
};

const driveFileEntity = {
  name: "File",
  sourceIntegration: "google" as const,
  identifiers: ["id"],
  supportedActions: ["google.drive.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "name", type: "string" },
    { name: "mimeType", type: "string" },
    { name: "modifiedTime", type: "string" },
    { name: "webViewLink", type: "string" },
  ],
};

const useCases: UseCaseDefinition[] = [
  {
    id: "featured-inbox-priority-radar",
    name: "Inbox Priority Radar",
    description: "Surface the most urgent emails with context-rich previews.",
    category: "Featured",
    integrations: ["google"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Show my most urgent emails from the last 48 hours with sender, subject, and snippet.",
    spec: buildSpec({
      id: "featured-inbox-priority-radar",
      name: "Inbox Priority Radar",
      description: "Prioritize urgent emails with the latest context.",
      purpose: "Identify urgent inbound emails from the last 48 hours.",
      integrations: ["google"],
      entities: [emailEntity],
      actions: [
        {
          id: "google.gmail.priority",
          name: "List recent priority emails",
          description: "Fetch high priority emails from Gmail",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list",
          inputSchema: { query: "string", maxResults: "number" },
          outputSchema: { emails: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "inbox-priority-table",
          name: "Priority Inbox",
          type: "table",
          source: { entity: "Email", statePath: "google.emails" },
          fields: ["from", "subject", "snippet", "internalDate"],
          actions: ["google.gmail.priority"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.gmail.priority",
          query: { query: "newer_than:2d label:important" },
          fields: ["from", "subject", "snippet", "internalDate"],
          max_results: 20,
        },
      ],
      answer_contract: {
        entity_type: "email",
        required_constraints: [{ field: "labelIds", operator: "semantic_contains", value: "important" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
        result_shape: {
          kind: "list",
          fields: ["from", "subject", "snippet", "internalDate"],
          order_by: "internalDate",
          order_direction: "desc",
          limit: 20,
        },
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Return urgent, recent emails",
        sub_goals: ["Sort by recency", "Include sender and snippet"],
        constraints: ["Last 48 hours", "High priority labels"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Find high priority emails",
        integrations: ["google"],
        objects: ["Email"],
        filters: ["priority", "last 48 hours"],
        successCriteria: ["At least one recent email", "Includes sender and snippet"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      initialFetch: {
        entity: "Email",
        integrationId: "google",
        actionId: "google.gmail.priority",
        limit: 20,
        order_by: "internalDate",
        order_direction: "desc",
      },
      dataReadiness: { requiredEntities: ["Email"], minimumRecords: 1 },
    }),
  },
  {
    id: "featured-daily-focus-digest",
    name: "Daily Focus Digest",
    description: "A crisp, daily inbox briefing of what matters most.",
    category: "Featured",
    integrations: ["google"],
    trigger: "Time-based",
    output: "Summary",
    prompt: "Summarize the most important emails from the last 24 hours.",
    spec: buildSpec({
      id: "featured-daily-focus-digest",
      name: "Daily Focus Digest",
      description: "Generate a daily digest of important emails.",
      purpose: "Create a daily email digest with key threads.",
      integrations: ["google"],
      entities: [emailEntity],
      actions: [
        {
          id: "google.gmail.digest",
          name: "List daily emails",
          description: "Fetch daily emails",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list",
          inputSchema: { query: "string", maxResults: "number" },
          outputSchema: { emails: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "daily-digest-table",
          name: "Daily Digest",
          type: "table",
          source: { entity: "Email", statePath: "google.daily" },
          fields: ["from", "subject", "snippet", "internalDate"],
          actions: ["google.gmail.digest"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.gmail.digest",
          query: { query: "newer_than:1d -category:social" },
          fields: ["from", "subject", "snippet", "internalDate"],
          max_results: 25,
        },
      ],
      answer_contract: {
        entity_type: "email",
        required_constraints: [{ field: "internalDate", operator: "semantic_contains", value: "last 24 hours" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
        result_shape: {
          kind: "list",
          fields: ["from", "subject", "snippet", "internalDate"],
          order_by: "internalDate",
          order_direction: "desc",
          limit: 25,
        },
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Surface daily emails worth attention",
        sub_goals: ["Filter out low-signal categories", "Sort by recency"],
        constraints: ["Last 24 hours"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Daily email digest",
        integrations: ["google"],
        objects: ["Email"],
        filters: ["last 24 hours"],
        successCriteria: ["Recent emails returned", "Digest is limited"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      triggers: [
        {
          id: "daily-digest-cron",
          name: "Daily digest run",
          type: "cron",
          condition: { cron: "0 8 * * 1-5" },
          actionId: "google.gmail.digest",
          enabled: true,
        },
      ],
      initialFetch: {
        entity: "Email",
        integrationId: "google",
        actionId: "google.gmail.digest",
        limit: 25,
        order_by: "internalDate",
        order_direction: "desc",
      },
      dataReadiness: { requiredEntities: ["Email"], minimumRecords: 1 },
    }),
  },
  {
    id: "consumer-meeting-notes-extractor",
    name: "Meeting Notes Extractor",
    description: "Collect the latest meeting notes and extract highlights.",
    category: "Personal (Consumer)",
    integrations: ["google"],
    trigger: "Prompt-based",
    output: "Summary",
    prompt: "List the most recently updated meeting notes docs with titles and update times.",
    spec: buildSpec({
      id: "consumer-meeting-notes-extractor",
      name: "Meeting Notes Extractor",
      description: "Extract highlights from the most recent meeting notes.",
      purpose: "Find latest meeting notes in Google Drive.",
      integrations: ["google"],
      entities: [driveFileEntity],
      actions: [
        {
          id: "google.drive.meeting-notes",
          name: "List recent meeting notes",
          description: "Find meeting notes in Google Drive",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_drive_list",
          inputSchema: { query: "string", pageSize: "number" },
          outputSchema: { files: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "meeting-notes-table",
          name: "Recent Meeting Notes",
          type: "table",
          source: { entity: "File", statePath: "google.meeting_notes" },
          fields: ["name", "modifiedTime", "webViewLink"],
          actions: ["google.drive.meeting-notes"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.drive.meeting-notes",
          query: { q: "name contains 'Meeting' and mimeType contains 'document'" },
          fields: ["name", "modifiedTime", "webViewLink"],
          max_results: 15,
        },
      ],
      answer_contract: {
        entity_type: "file",
        required_constraints: [{ field: "name", operator: "semantic_contains", value: "Meeting" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
        result_shape: {
          kind: "list",
          fields: ["name", "modifiedTime", "webViewLink"],
          order_by: "modifiedTime",
          order_direction: "desc",
          limit: 15,
        },
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "List recent meeting notes documents",
        sub_goals: ["Return title and last updated time"],
        constraints: ["Docs only", "Most recent first"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Recent meeting notes",
        integrations: ["google"],
        objects: ["File"],
        filters: ["meeting notes", "recently updated"],
        successCriteria: ["Latest docs returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      initialFetch: {
        entity: "File",
        integrationId: "google",
        actionId: "google.drive.meeting-notes",
        limit: 15,
        order_by: "modifiedTime",
        order_direction: "desc",
      },
      dataReadiness: { requiredEntities: ["File"], minimumRecords: 1 },
    }),
  },
  {
    id: "consumer-weekly-goals-review",
    name: "Weekly Goals Review",
    description: "Track your top goals and open blockers each week.",
    category: "Personal (Consumer)",
    integrations: ["linear", "notion"],
    trigger: "Time-based",
    output: "Table",
    prompt: "Review my open goals and blockers for the week.",
    spec: buildSpec({
      id: "consumer-weekly-goals-review",
      name: "Weekly Goals Review",
      description: "Review open goals and blockers.",
      purpose: "Summarize weekly goals and blockers across Linear and Notion.",
      integrations: ["linear", "notion"],
      entities: [linearIssueEntity, notionPageEntity],
      actions: [
        {
          id: "linear.weekly.goals",
          name: "List weekly Linear issues",
          description: "Fetch open Linear issues",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list",
          inputSchema: { state: "string", limit: "number" },
          outputSchema: { issues: "array" },
          writesToState: false,
        },
        {
          id: "notion.weekly.goals",
          name: "Search Notion goals",
          description: "Find goals in Notion",
          type: "READ",
          integrationId: "notion",
          capabilityId: "notion_pages_search",
          inputSchema: { query: "string" },
          outputSchema: { pages: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "weekly-goals-linear",
          name: "Linear Goals",
          type: "table",
          source: { entity: "Issue", statePath: "linear.goals" },
          fields: ["title", "state", "assignee", "priority"],
          actions: ["linear.weekly.goals"],
        },
        {
          id: "weekly-goals-notion",
          name: "Notion Goals",
          type: "table",
          source: { entity: "Page", statePath: "notion.goals" },
          fields: ["title", "lastEdited", "url"],
          actions: ["notion.weekly.goals"],
        },
      ],
      query_plans: [
        {
          integrationId: "linear",
          actionId: "linear.weekly.goals",
          query: { includeArchived: false },
          fields: ["title", "state", "assignee", "priority"],
          max_results: 20,
        },
        {
          integrationId: "notion",
          actionId: "notion.weekly.goals",
          query: { query: "goal OR OKR" },
          fields: ["title", "lastEdited", "url"],
          max_results: 10,
        },
      ],
      answer_contract: {
        entity_type: "issue",
        required_constraints: [{ field: "state", operator: "semantic_contains", value: "open" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
        result_shape: {
          kind: "list",
          fields: ["title", "state", "assignee", "priority"],
          limit: 20,
        },
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Review open goals and blockers",
        sub_goals: ["List open Linear issues", "Pull relevant Notion pages"],
        constraints: ["Open only"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Weekly goals review",
        integrations: ["linear", "notion"],
        objects: ["Issue", "Page"],
        filters: ["open", "weekly"],
        successCriteria: ["Open goals returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      triggers: [
        {
          id: "weekly-goals-cron",
          name: "Weekly goals review",
          type: "cron",
          condition: { cron: "0 9 * * MON" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["Issue", "Page"], minimumRecords: 1 },
    }),
  },
  {
    id: "consumer-travel-itinerary-intel",
    name: "Travel Itinerary Intelligence",
    description: "Aggregate upcoming travel confirmations in one view.",
    category: "Personal (Consumer)",
    integrations: ["google"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Find my upcoming travel confirmations and show dates, senders, and subjects.",
    spec: buildSpec({
      id: "consumer-travel-itinerary-intel",
      name: "Travel Itinerary Intelligence",
      description: "Aggregate upcoming travel confirmations.",
      purpose: "Find travel-related emails for upcoming trips.",
      integrations: ["google"],
      entities: [emailEntity],
      actions: [
        {
          id: "google.gmail.travel",
          name: "Search travel emails",
          description: "Fetch travel-related emails",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list",
          inputSchema: { query: "string", maxResults: "number" },
          outputSchema: { emails: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "travel-table",
          name: "Travel Confirmations",
          type: "table",
          source: { entity: "Email", statePath: "google.travel" },
          fields: ["from", "subject", "snippet", "internalDate"],
          actions: ["google.gmail.travel"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.gmail.travel",
          query: { query: "itinerary OR booking OR reservation newer_than:30d" },
          fields: ["from", "subject", "snippet", "internalDate"],
          max_results: 25,
        },
      ],
      answer_contract: {
        entity_type: "email",
        required_constraints: [{ field: "subject", operator: "semantic_contains", value: "reservation" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
        result_shape: {
          kind: "list",
          fields: ["from", "subject", "snippet", "internalDate"],
          order_by: "internalDate",
          order_direction: "desc",
          limit: 25,
        },
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "List upcoming travel confirmations",
        sub_goals: ["Identify travel keywords", "Sort by recency"],
        constraints: ["Last 30 days"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Travel itinerary emails",
        integrations: ["google"],
        objects: ["Email"],
        filters: ["travel confirmations", "last 30 days"],
        successCriteria: ["Travel confirmations returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      dataReadiness: { requiredEntities: ["Email"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-sales-pipeline-intel",
    name: "Sales Pipeline Intelligence",
    description: "Monitor live deal momentum and high-risk opportunities.",
    category: "Sales",
    integrations: ["slack", "notion"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Show the latest high-risk deals and sales updates.",
    spec: buildSpec({
      id: "enterprise-sales-pipeline-intel",
      name: "Sales Pipeline Intelligence",
      description: "Track deal updates and risk signals.",
      purpose: "Monitor deal momentum from Notion and Slack updates.",
      integrations: ["slack", "notion"],
      entities: [slackMessageEntity, notionPageEntity],
      actions: [
        {
          id: "slack.sales.updates",
          name: "Search sales updates",
          description: "Fetch sales updates from Slack",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_search_messages",
          inputSchema: { query: "string", count: "number" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
        {
          id: "notion.deals.search",
          name: "Search sales pages",
          description: "Find sales pages in Notion",
          type: "READ",
          integrationId: "notion",
          capabilityId: "notion_pages_search",
          inputSchema: { query: "string" },
          outputSchema: { pages: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "sales-slack-table",
          name: "Slack Sales Updates",
          type: "table",
          source: { entity: "Message", statePath: "slack.sales_updates" },
          fields: ["channel", "user", "text", "timestamp"],
          actions: ["slack.sales.updates"],
        },
        {
          id: "sales-notion-table",
          name: "Notion Deal Pages",
          type: "table",
          source: { entity: "Page", statePath: "notion.sales_pages" },
          fields: ["title", "lastEdited", "url"],
          actions: ["notion.deals.search"],
        },
      ],
      query_plans: [
        {
          integrationId: "slack",
          actionId: "slack.sales.updates",
          query: { query: "deal OR pipeline OR renewal" },
          fields: ["channel", "user", "text", "timestamp"],
          max_results: 20,
        },
        {
          integrationId: "notion",
          actionId: "notion.deals.search",
          query: { query: "deal" },
          fields: ["title", "lastEdited", "url"],
          max_results: 10,
        },
      ],
      answer_contract: {
        entity_type: "message",
        required_constraints: [{ field: "text", operator: "semantic_contains", value: "deal" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
        result_shape: {
          kind: "list",
          fields: ["channel", "user", "text", "timestamp"],
          limit: 20,
        },
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Surface high-risk sales pipeline updates",
        sub_goals: ["Collect sales updates", "Highlight deal changes"],
        constraints: ["Recent updates"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Sales pipeline updates",
        integrations: ["slack", "notion"],
        objects: ["Message", "Page"],
        filters: ["deal updates", "pipeline"],
        successCriteria: ["Recent sales messages", "Deal pages found"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      dataReadiness: { requiredEntities: ["Message", "Page"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-engineering-velocity",
    name: "Engineering Velocity & Risk Monitor",
    description: "Track delivery velocity and emerging risks across GitHub and Linear.",
    category: "Engineering",
    integrations: ["github", "linear"],
    trigger: "Time-based",
    output: "Table",
    prompt: "Summarize current engineering velocity and risks.",
    spec: buildSpec({
      id: "enterprise-engineering-velocity",
      name: "Engineering Velocity & Risk Monitor",
      description: "Monitor delivery velocity and risk signals.",
      purpose: "Track open issues and risks across GitHub and Linear.",
      integrations: ["github", "linear"],
      entities: [githubIssueEntity, linearIssueEntity],
      actions: [
        {
          id: "github.issues.risk",
          name: "Search GitHub risk issues",
          description: "Fetch risk-tagged GitHub issues",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_issues_search",
          inputSchema: { query: "string" },
          outputSchema: { issues: "array" },
          writesToState: false,
        },
        {
          id: "linear.issues.risk",
          name: "List Linear high priority issues",
          description: "Fetch high priority Linear issues",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list",
          inputSchema: { includeArchived: "boolean" },
          outputSchema: { issues: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "github-risk-table",
          name: "GitHub Risk Issues",
          type: "table",
          source: { entity: "Issue", statePath: "github.risk_issues" },
          fields: ["title", "state", "url"],
          actions: ["github.issues.risk"],
        },
        {
          id: "linear-risk-table",
          name: "Linear Risk Issues",
          type: "table",
          source: { entity: "Issue", statePath: "linear.risk_issues" },
          fields: ["title", "state", "assignee", "priority"],
          actions: ["linear.issues.risk"],
        },
      ],
      query_plans: [
        {
          integrationId: "github",
          actionId: "github.issues.risk",
          query: { q: "is:issue is:open label:risk" },
          fields: ["title", "state", "url"],
          max_results: 25,
        },
        {
          integrationId: "linear",
          actionId: "linear.issues.risk",
          query: { includeArchived: false },
          fields: ["title", "state", "assignee", "priority"],
          max_results: 25,
        },
      ],
      answer_contract: {
        entity_type: "issue",
        required_constraints: [{ field: "state", operator: "semantic_contains", value: "open" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
        result_shape: {
          kind: "list",
          fields: ["title", "state", "assignee", "priority"],
          limit: 25,
        },
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Track engineering velocity and risks",
        sub_goals: ["Collect open GitHub issues", "Collect high priority Linear issues"],
        constraints: ["Open only"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Engineering velocity and risk",
        integrations: ["github", "linear"],
        objects: ["Issue"],
        filters: ["risk", "open"],
        successCriteria: ["Open issues returned", "High priority risks visible"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      triggers: [
        {
          id: "engineering-weekly",
          name: "Weekly engineering pulse",
          type: "cron",
          condition: { cron: "0 9 * * MON" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-exec-weekly-review",
    name: "Executive Weekly Business Review",
    description: "Pull leadership-grade updates from Slack and shared docs.",
    category: "Leadership / Exec",
    integrations: ["slack", "google"],
    trigger: "Time-based",
    output: "Summary",
    prompt: "Compile a weekly executive review from key updates.",
    spec: buildSpec({
      id: "enterprise-exec-weekly-review",
      name: "Executive Weekly Business Review",
      description: "Summarize weekly executive updates.",
      purpose: "Compile key updates from Slack and Drive.",
      integrations: ["slack", "google"],
      entities: [slackMessageEntity, driveFileEntity],
      actions: [
        {
          id: "slack.exec.updates",
          name: "Search executive updates",
          description: "Fetch exec updates from Slack",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_search_messages",
          inputSchema: { query: "string", count: "number" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
        {
          id: "google.drive.exec-docs",
          name: "List exec docs",
          description: "Fetch executive docs from Drive",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_drive_list",
          inputSchema: { query: "string", pageSize: "number" },
          outputSchema: { files: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "exec-slack-table",
          name: "Executive Updates",
          type: "table",
          source: { entity: "Message", statePath: "slack.exec_updates" },
          fields: ["channel", "user", "text", "timestamp"],
          actions: ["slack.exec.updates"],
        },
        {
          id: "exec-docs-table",
          name: "Executive Docs",
          type: "table",
          source: { entity: "File", statePath: "google.exec_docs" },
          fields: ["name", "modifiedTime", "webViewLink"],
          actions: ["google.drive.exec-docs"],
        },
      ],
      query_plans: [
        {
          integrationId: "slack",
          actionId: "slack.exec.updates",
          query: { query: "exec update OR weekly review" },
          fields: ["channel", "user", "text", "timestamp"],
          max_results: 20,
        },
        {
          integrationId: "google",
          actionId: "google.drive.exec-docs",
          query: { q: "name contains 'Exec' or name contains 'Board' and mimeType contains 'document'" },
          fields: ["name", "modifiedTime", "webViewLink"],
          max_results: 10,
        },
      ],
      answer_contract: {
        entity_type: "message",
        required_constraints: [{ field: "text", operator: "semantic_contains", value: "update" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Deliver weekly executive review",
        sub_goals: ["Collect executive Slack updates", "Gather executive docs"],
        constraints: ["Last 7 days"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Executive weekly review",
        integrations: ["slack", "google"],
        objects: ["Message", "File"],
        filters: ["weekly", "exec updates"],
        successCriteria: ["Exec updates found", "Docs found"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      triggers: [
        {
          id: "exec-weekly-cron",
          name: "Executive weekly review",
          type: "cron",
          condition: { cron: "0 8 * * MON" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["Message", "File"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-security-incident",
    name: "Security & Incident Detection",
    description: "Detect security and incident signals across Slack and GitHub.",
    category: "Operations",
    integrations: ["slack", "github"],
    trigger: "Event-based",
    output: "Alert",
    prompt: "Detect security and incident signals from Slack and GitHub.",
    spec: buildSpec({
      id: "enterprise-security-incident",
      name: "Security & Incident Detection",
      description: "Detect security and incident signals.",
      purpose: "Identify security incidents in Slack and GitHub.",
      integrations: ["slack", "github"],
      entities: [slackMessageEntity, githubIssueEntity],
      actions: [
        {
          id: "slack.security.alerts",
          name: "Search incident messages",
          description: "Fetch incident messages from Slack",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_search_messages",
          inputSchema: { query: "string", count: "number" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
        {
          id: "github.security.issues",
          name: "Search security issues",
          description: "Fetch security issues from GitHub",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_issues_search",
          inputSchema: { query: "string" },
          outputSchema: { issues: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "security-slack",
          name: "Incident Slack Signals",
          type: "table",
          source: { entity: "Message", statePath: "slack.security_signals" },
          fields: ["channel", "user", "text", "timestamp"],
          actions: ["slack.security.alerts"],
        },
        {
          id: "security-github",
          name: "Security Issues",
          type: "table",
          source: { entity: "Issue", statePath: "github.security_issues" },
          fields: ["title", "state", "url"],
          actions: ["github.security.issues"],
        },
      ],
      query_plans: [
        {
          integrationId: "slack",
          actionId: "slack.security.alerts",
          query: { query: "incident OR outage OR security" },
          fields: ["channel", "user", "text", "timestamp"],
          max_results: 20,
        },
        {
          integrationId: "github",
          actionId: "github.security.issues",
          query: { q: "is:issue is:open label:security" },
          fields: ["title", "state", "url"],
          max_results: 20,
        },
      ],
      answer_contract: {
        entity_type: "message",
        required_constraints: [{ field: "text", operator: "semantic_contains", value: "incident" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Detect security and incident signals",
        sub_goals: ["Find incident messages", "Find security issues"],
        constraints: ["Open incidents"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Security incident detection",
        integrations: ["slack", "github"],
        objects: ["Message", "Issue"],
        filters: ["incident", "security"],
        successCriteria: ["Incident signals detected"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      triggers: [
        {
          id: "security-event",
          name: "Incident signal trigger",
          type: "integration_event",
          condition: { event: "message_posted", keyword: "incident" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["Message", "Issue"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-feedback-intelligence",
    name: "Customer Feedback Intelligence",
    description: "Aggregate customer feedback signals from Slack and Notion.",
    category: "Marketing",
    integrations: ["slack", "notion"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Aggregate customer feedback signals from Slack and Notion.",
    spec: buildSpec({
      id: "enterprise-feedback-intelligence",
      name: "Customer Feedback Intelligence",
      description: "Aggregate customer feedback signals.",
      purpose: "Compile feedback from Slack and Notion.",
      integrations: ["slack", "notion"],
      entities: [slackMessageEntity, notionPageEntity],
      actions: [
        {
          id: "slack.feedback.search",
          name: "Search feedback messages",
          description: "Fetch feedback messages from Slack",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_search_messages",
          inputSchema: { query: "string", count: "number" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
        {
          id: "notion.feedback.search",
          name: "Search feedback pages",
          description: "Find feedback pages in Notion",
          type: "READ",
          integrationId: "notion",
          capabilityId: "notion_pages_search",
          inputSchema: { query: "string" },
          outputSchema: { pages: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "feedback-slack-table",
          name: "Slack Feedback",
          type: "table",
          source: { entity: "Message", statePath: "slack.feedback" },
          fields: ["channel", "user", "text", "timestamp"],
          actions: ["slack.feedback.search"],
        },
        {
          id: "feedback-notion-table",
          name: "Notion Feedback",
          type: "table",
          source: { entity: "Page", statePath: "notion.feedback" },
          fields: ["title", "lastEdited", "url"],
          actions: ["notion.feedback.search"],
        },
      ],
      query_plans: [
        {
          integrationId: "slack",
          actionId: "slack.feedback.search",
          query: { query: "feedback OR request OR complaint" },
          fields: ["channel", "user", "text", "timestamp"],
          max_results: 20,
        },
        {
          integrationId: "notion",
          actionId: "notion.feedback.search",
          query: { query: "feedback" },
          fields: ["title", "lastEdited", "url"],
          max_results: 10,
        },
      ],
      answer_contract: {
        entity_type: "message",
        required_constraints: [{ field: "text", operator: "semantic_contains", value: "feedback" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Aggregate customer feedback",
        sub_goals: ["Collect Slack feedback", "Collect Notion feedback pages"],
        constraints: ["Recent feedback"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Customer feedback aggregation",
        integrations: ["slack", "notion"],
        objects: ["Message", "Page"],
        filters: ["feedback"],
        successCriteria: ["Feedback signals returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      dataReadiness: { requiredEntities: ["Message", "Page"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-board-meeting-intel",
    name: "Board Meeting Intelligence",
    description: "Centralize board materials and recent updates.",
    category: "Leadership / Exec",
    integrations: ["google"],
    trigger: "Prompt-based",
    output: "Document",
    prompt: "List the latest board materials and summaries.",
    spec: buildSpec({
      id: "enterprise-board-meeting-intel",
      name: "Board Meeting Intelligence",
      description: "Centralize board materials and updates.",
      purpose: "Find latest board materials in Drive.",
      integrations: ["google"],
      entities: [driveFileEntity],
      actions: [
        {
          id: "google.drive.board",
          name: "List board materials",
          description: "Fetch board docs and slides",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_drive_list",
          inputSchema: { query: "string", pageSize: "number" },
          outputSchema: { files: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "board-materials-table",
          name: "Board Materials",
          type: "table",
          source: { entity: "File", statePath: "google.board_materials" },
          fields: ["name", "mimeType", "modifiedTime", "webViewLink"],
          actions: ["google.drive.board"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.drive.board",
          query: { q: "name contains 'Board' or name contains 'QBR'" },
          fields: ["name", "mimeType", "modifiedTime", "webViewLink"],
          max_results: 15,
        },
      ],
      answer_contract: {
        entity_type: "file",
        required_constraints: [{ field: "name", operator: "semantic_contains", value: "Board" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "List board meeting materials",
        sub_goals: ["Find recent board docs", "Include slides and docs"],
        constraints: ["Most recent first"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Board materials",
        integrations: ["google"],
        objects: ["File"],
        filters: ["board", "qbr"],
        successCriteria: ["Board materials returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      dataReadiness: { requiredEntities: ["File"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-investor-update-intel",
    name: "Investor Update Intelligence",
    description: "Assemble investor updates and progress signals.",
    category: "Leadership / Exec",
    integrations: ["google"],
    trigger: "Time-based",
    output: "Document",
    prompt: "Compile the latest investor update materials.",
    spec: buildSpec({
      id: "enterprise-investor-update-intel",
      name: "Investor Update Intelligence",
      description: "Assemble investor updates.",
      purpose: "Collect investor update materials from Drive.",
      integrations: ["google"],
      entities: [driveFileEntity],
      actions: [
        {
          id: "google.drive.investor",
          name: "List investor updates",
          description: "Fetch investor update docs",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_drive_list",
          inputSchema: { query: "string", pageSize: "number" },
          outputSchema: { files: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "investor-docs-table",
          name: "Investor Update Materials",
          type: "table",
          source: { entity: "File", statePath: "google.investor_updates" },
          fields: ["name", "modifiedTime", "webViewLink"],
          actions: ["google.drive.investor"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.drive.investor",
          query: { q: "name contains 'Investor' or name contains 'Update'" },
          fields: ["name", "modifiedTime", "webViewLink"],
          max_results: 15,
        },
      ],
      answer_contract: {
        entity_type: "file",
        required_constraints: [{ field: "name", operator: "semantic_contains", value: "Investor" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Assemble investor update materials",
        sub_goals: ["Collect latest investor docs"],
        constraints: ["Most recent first"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Investor update materials",
        integrations: ["google"],
        objects: ["File"],
        filters: ["investor", "update"],
        successCriteria: ["Investor materials returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      triggers: [
        {
          id: "investor-monthly",
          name: "Monthly investor update",
          type: "cron",
          condition: { cron: "0 8 1 * *" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["File"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-codebase-health",
    name: "Codebase Health & Technical Debt Analyzer",
    description: "Identify aging issues, backlog debt, and neglected repos.",
    category: "Engineering",
    integrations: ["github"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Identify aging issues and technical debt hotspots.",
    spec: buildSpec({
      id: "enterprise-codebase-health",
      name: "Codebase Health & Technical Debt Analyzer",
      description: "Identify technical debt hotspots.",
      purpose: "Analyze aging GitHub issues for technical debt.",
      integrations: ["github"],
      entities: [githubIssueEntity],
      actions: [
        {
          id: "github.debt.issues",
          name: "Search stale issues",
          description: "Fetch long-running issues",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_issues_search",
          inputSchema: { query: "string" },
          outputSchema: { issues: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "debt-issues-table",
          name: "Stale Issues",
          type: "table",
          source: { entity: "Issue", statePath: "github.debt_issues" },
          fields: ["title", "state", "url"],
          actions: ["github.debt.issues"],
        },
      ],
      query_plans: [
        {
          integrationId: "github",
          actionId: "github.debt.issues",
          query: { q: "is:issue is:open sort:updated-asc" },
          fields: ["title", "state", "url"],
          max_results: 25,
        },
      ],
      answer_contract: {
        entity_type: "issue",
        required_constraints: [{ field: "state", operator: "semantic_contains", value: "open" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Identify technical debt hotspots",
        sub_goals: ["Find stale open issues"],
        constraints: ["Oldest updated first"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Codebase health",
        integrations: ["github"],
        objects: ["Issue"],
        filters: ["stale", "open"],
        successCriteria: ["Stale issues returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-design-sprint-insights",
    name: "Design Sprint Asset Tracker",
    description: "Track design sprint artifacts across Notion and Drive.",
    category: "Design",
    integrations: ["notion", "google"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "List design sprint artifacts and recent updates.",
    spec: buildSpec({
      id: "enterprise-design-sprint-insights",
      name: "Design Sprint Asset Tracker",
      description: "Track design sprint assets.",
      purpose: "Find design sprint artifacts across Notion and Drive.",
      integrations: ["notion", "google"],
      entities: [notionPageEntity, driveFileEntity],
      actions: [
        {
          id: "notion.design.search",
          name: "Search design pages",
          description: "Fetch design sprint pages",
          type: "READ",
          integrationId: "notion",
          capabilityId: "notion_pages_search",
          inputSchema: { query: "string" },
          outputSchema: { pages: "array" },
          writesToState: false,
        },
        {
          id: "google.drive.design",
          name: "List design assets",
          description: "Fetch design assets from Drive",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_drive_list",
          inputSchema: { query: "string" },
          outputSchema: { files: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "design-notion-table",
          name: "Design Pages",
          type: "table",
          source: { entity: "Page", statePath: "notion.design_pages" },
          fields: ["title", "lastEdited", "url"],
          actions: ["notion.design.search"],
        },
        {
          id: "design-drive-table",
          name: "Drive Assets",
          type: "table",
          source: { entity: "File", statePath: "google.design_assets" },
          fields: ["name", "modifiedTime", "webViewLink"],
          actions: ["google.drive.design"],
        },
      ],
      query_plans: [
        {
          integrationId: "notion",
          actionId: "notion.design.search",
          query: { query: "design sprint OR UX" },
          fields: ["title", "lastEdited", "url"],
          max_results: 10,
        },
        {
          integrationId: "google",
          actionId: "google.drive.design",
          query: { q: "name contains 'Design' or name contains 'Sprint'" },
          fields: ["name", "modifiedTime", "webViewLink"],
          max_results: 15,
        },
      ],
      answer_contract: {
        entity_type: "page",
        required_constraints: [{ field: "title", operator: "semantic_contains", value: "Design" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Track design sprint assets",
        sub_goals: ["List Notion sprint pages", "List Drive assets"],
        constraints: ["Most recent first"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Design sprint assets",
        integrations: ["notion", "google"],
        objects: ["Page", "File"],
        filters: ["design sprint", "ux"],
        successCriteria: ["Design artifacts returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      dataReadiness: { requiredEntities: ["Page", "File"], minimumRecords: 1 },
    }),
  },
  // ===== CONSUMER-GRADE USE CASES =====
  {
    id: "consumer-inbox-zero-assistant",
    name: "Inbox Zero Assistant",
    description: "Analyze emails and suggest what to archive, respond to, or defer.",
    category: "Personal (Consumer)",
    integrations: ["google"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Analyze my inbox and categorize emails into archive, respond, or defer.",
    spec: buildSpec({
      id: "consumer-inbox-zero-assistant",
      name: "Inbox Zero Assistant",
      description: "Analyze inbox for action items.",
      purpose: "Help achieve inbox zero by categorizing emails.",
      integrations: ["google"],
      entities: [emailEntity],
      actions: [
        {
          id: "google.gmail.inbox",
          name: "List inbox emails",
          description: "Fetch unread inbox emails",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list",
          inputSchema: { query: "string", maxResults: "number" },
          outputSchema: { emails: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "inbox-zero-table",
          name: "Email Actions",
          type: "table",
          source: { entity: "Email", statePath: "google.inbox" },
          fields: ["from", "subject", "snippet", "internalDate"],
          actions: ["google.gmail.inbox"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.gmail.inbox",
          query: { query: "is:inbox is:unread" },
          fields: ["from", "subject", "snippet", "internalDate"],
          max_results: 30,
        },
      ],
      answer_contract: {
        entity_type: "email",
        required_constraints: [{ field: "labelIds", operator: "semantic_contains", value: "inbox" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Categorize inbox emails for action",
        sub_goals: ["Fetch unread emails", "Suggest actions"],
        constraints: ["Unread only"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Inbox zero assistance",
        integrations: ["google"],
        objects: ["Email"],
        filters: ["unread", "inbox"],
        successCriteria: ["Emails categorized"],
        forbiddenOutputs: ["dummy", "mock"],
      }),
      dataReadiness: { requiredEntities: ["Email"], minimumRecords: 1 },
    }),
  },
  {
    id: "consumer-meeting-prep-briefing",
    name: "Meeting Prep Briefing",
    description: "Compile a briefing for your upcoming meetings with context from emails and docs.",
    category: "Personal (Consumer)",
    integrations: ["google"],
    trigger: "Time-based",
    output: "Summary",
    prompt: "Create a meeting prep briefing for my meetings today.",
    spec: buildSpec({
      id: "consumer-meeting-prep-briefing",
      name: "Meeting Prep Briefing",
      description: "Prepare context for upcoming meetings.",
      purpose: "Compile meeting briefs from calendar and related emails.",
      integrations: ["google"],
      entities: [emailEntity, driveFileEntity],
      actions: [
        {
          id: "google.gmail.meeting",
          name: "Search meeting emails",
          description: "Find emails related to meetings",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list",
          inputSchema: { query: "string" },
          outputSchema: { emails: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "meeting-prep-table",
          name: "Meeting Context",
          type: "table",
          source: { entity: "Email", statePath: "google.meeting_emails" },
          fields: ["from", "subject", "snippet"],
          actions: ["google.gmail.meeting"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.gmail.meeting",
          query: { query: "newer_than:7d (meeting OR call OR sync)" },
          fields: ["from", "subject", "snippet"],
          max_results: 20,
        },
      ],
      answer_contract: {
        entity_type: "email",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Compile meeting prep",
        sub_goals: ["Find relevant emails", "Extract context"],
        constraints: ["Recent emails"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Meeting preparation",
        integrations: ["google"],
        objects: ["Email"],
        filters: ["meeting"],
        successCriteria: ["Context gathered"],
        forbiddenOutputs: ["dummy"],
      }),
      triggers: [
        {
          id: "meeting-prep-daily",
          name: "Daily meeting prep",
          type: "cron",
          condition: { cron: "0 7 * * 1-5" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["Email"], minimumRecords: 1 },
    }),
  },
  {
    id: "consumer-email-followup-drafter",
    name: "Email Follow-Up Drafter",
    description: "Find emails awaiting response and draft follow-ups.",
    category: "Personal (Consumer)",
    integrations: ["google"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Find emails I need to follow up on and suggest draft responses.",
    spec: buildSpec({
      id: "consumer-email-followup-drafter",
      name: "Email Follow-Up Drafter",
      description: "Draft follow-up emails.",
      purpose: "Identify and draft follow-ups.",
      integrations: ["google"],
      entities: [emailEntity],
      actions: [
        {
          id: "google.gmail.followup",
          name: "Search awaiting emails",
          description: "Find emails needing follow-up",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list",
          inputSchema: { query: "string" },
          outputSchema: { emails: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "followup-table",
          name: "Follow-Ups Needed",
          type: "table",
          source: { entity: "Email", statePath: "google.followups" },
          fields: ["from", "subject", "snippet", "internalDate"],
          actions: ["google.gmail.followup"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.gmail.followup",
          query: { query: "is:sent older_than:3d -is:draft" },
          fields: ["from", "subject", "snippet", "internalDate"],
          max_results: 20,
        },
      ],
      answer_contract: {
        entity_type: "email",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Identify follow-up needs",
        sub_goals: ["Find sent emails", "Check for responses"],
        constraints: ["Older than 3 days"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Email follow-ups",
        integrations: ["google"],
        objects: ["Email"],
        filters: ["sent", "no response"],
        successCriteria: ["Follow-ups identified"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Email"], minimumRecords: 1 },
    }),
  },
  {
    id: "consumer-slack-catchup-summary",
    name: "Slack Catch-Up Summary",
    description: "Summarize important Slack messages you may have missed.",
    category: "Personal (Consumer)",
    integrations: ["slack"],
    trigger: "Prompt-based",
    output: "Summary",
    prompt: "Summarize important Slack messages from the last 24 hours.",
    spec: buildSpec({
      id: "consumer-slack-catchup-summary",
      name: "Slack Catch-Up Summary",
      description: "Catch up on Slack.",
      purpose: "Summarize missed Slack messages.",
      integrations: ["slack"],
      entities: [slackMessageEntity],
      actions: [
        {
          id: "slack.messages.recent",
          name: "Search recent messages",
          description: "Fetch recent important messages",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_search_messages",
          inputSchema: { query: "string", count: "number" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "slack-catchup-table",
          name: "Slack Summary",
          type: "table",
          source: { entity: "Message", statePath: "slack.recent" },
          fields: ["channel", "user", "text", "timestamp"],
          actions: ["slack.messages.recent"],
        },
      ],
      query_plans: [
        {
          integrationId: "slack",
          actionId: "slack.messages.recent",
          query: { query: "in:* after:yesterday" },
          fields: ["channel", "user", "text", "timestamp"],
          max_results: 50,
        },
      ],
      answer_contract: {
        entity_type: "message",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Summarize Slack activity",
        sub_goals: ["Fetch recent messages", "Highlight important ones"],
        constraints: ["Last 24 hours"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Slack catch-up",
        integrations: ["slack"],
        objects: ["Message"],
        filters: ["recent"],
        successCriteria: ["Messages summarized"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Message"], minimumRecords: 1 },
    }),
  },
  {
    id: "consumer-document-research",
    name: "Document Research Synthesizer",
    description: "Search and synthesize information from your Drive documents.",
    category: "Personal (Consumer)",
    integrations: ["google"],
    trigger: "Prompt-based",
    output: "Summary",
    prompt: "Find and synthesize key insights from documents about {{topic}}.",
    spec: buildSpec({
      id: "consumer-document-research",
      name: "Document Research Synthesizer",
      description: "Synthesize document insights.",
      purpose: "Research and synthesize from Drive.",
      integrations: ["google"],
      entities: [driveFileEntity],
      actions: [
        {
          id: "google.drive.research",
          name: "Search Drive docs",
          description: "Search documents",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_drive_list",
          inputSchema: { query: "string" },
          outputSchema: { files: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "research-docs-table",
          name: "Research Documents",
          type: "table",
          source: { entity: "File", statePath: "google.research_docs" },
          fields: ["name", "modifiedTime", "webViewLink"],
          actions: ["google.drive.research"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.drive.research",
          query: { q: "mimeType contains 'document'" },
          fields: ["name", "modifiedTime", "webViewLink"],
          max_results: 20,
        },
      ],
      answer_contract: {
        entity_type: "file",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Research topic across docs",
        sub_goals: ["Find relevant docs", "Extract insights"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Document research",
        integrations: ["google"],
        objects: ["File"],
        filters: ["documents"],
        successCriteria: ["Insights synthesized"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["File"], minimumRecords: 1 },
    }),
  },
  {
    id: "consumer-weekly-focus-report",
    name: "Weekly Focus Report",
    description: "Generate a report of your Week's work across Linear issues and docs.",
    category: "Personal (Consumer)",
    integrations: ["linear", "notion"],
    trigger: "Time-based",
    output: "Document",
    prompt: "Generate a weekly focus report from my Linear issues and Notion docs.",
    spec: buildSpec({
      id: "consumer-weekly-focus-report",
      name: "Weekly Focus Report",
      description: "Weekly work summary.",
      purpose: "Compile weekly work report.",
      integrations: ["linear", "notion"],
      entities: [linearIssueEntity, notionPageEntity],
      actions: [
        {
          id: "linear.weekly.issues",
          name: "List week's issues",
          description: "Get issues worked on",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list",
          inputSchema: {},
          outputSchema: { issues: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "weekly-issues-table",
          name: "Weekly Issues",
          type: "table",
          source: { entity: "Issue", statePath: "linear.weekly" },
          fields: ["title", "state", "priority"],
          actions: ["linear.weekly.issues"],
        },
      ],
      query_plans: [
        {
          integrationId: "linear",
          actionId: "linear.weekly.issues",
          query: {},
          fields: ["title", "state", "priority"],
          max_results: 30,
        },
      ],
      answer_contract: {
        entity_type: "issue",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Compile weekly focus",
        sub_goals: ["Gather issues", "Gather docs"],
        constraints: ["This week"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Weekly focus report",
        integrations: ["linear", "notion"],
        objects: ["Issue", "Page"],
        successCriteria: ["Report generated"],
        forbiddenOutputs: ["dummy"],
      }),
      triggers: [
        {
          id: "weekly-report-cron",
          name: "Weekly report",
          type: "cron",
          condition: { cron: "0 17 * * FRI" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 1 },
    }),
  },
  {
    id: "consumer-attachment-finder",
    name: "Attachment Finder",
    description: "Find attachments from your emails matching specific criteria.",
    category: "Personal (Consumer)",
    integrations: ["google"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Find email attachments from the last month.",
    spec: buildSpec({
      id: "consumer-attachment-finder",
      name: "Attachment Finder",
      description: "Find email attachments.",
      purpose: "Search for attachments in emails.",
      integrations: ["google"],
      entities: [emailEntity],
      actions: [
        {
          id: "google.gmail.attachments",
          name: "Search attachments",
          description: "Find emails with attachments",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list",
          inputSchema: { query: "string" },
          outputSchema: { emails: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "attachments-table",
          name: "Attachments",
          type: "table",
          source: { entity: "Email", statePath: "google.attachments" },
          fields: ["from", "subject", "internalDate"],
          actions: ["google.gmail.attachments"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.gmail.attachments",
          query: { query: "has:attachment newer_than:30d" },
          fields: ["from", "subject", "internalDate"],
          max_results: 25,
        },
      ],
      answer_contract: {
        entity_type: "email",
        required_constraints: [{ field: "hasAttachment", operator: "semantic_contains", value: "true" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Find attachments",
        sub_goals: ["Search emails with attachments"],
        constraints: ["Last 30 days"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Find attachments",
        integrations: ["google"],
        objects: ["Email"],
        filters: ["attachments"],
        successCriteria: ["Attachments found"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Email"], minimumRecords: 1 },
    }),
  },
  {
    id: "consumer-contact-context-builder",
    name: "Contact Context Builder",
    description: "Build context about a contact from emails and Slack.",
    category: "Personal (Consumer)",
    integrations: ["google", "slack"],
    trigger: "Prompt-based",
    output: "Summary",
    prompt: "Build context about {{contact_name}} from my emails and Slack.",
    spec: buildSpec({
      id: "consumer-contact-context-builder",
      name: "Contact Context Builder",
      description: "Build contact context.",
      purpose: "Gather all context about a person.",
      integrations: ["google", "slack"],
      entities: [emailEntity, slackMessageEntity],
      actions: [
        {
          id: "google.gmail.contact",
          name: "Search contact emails",
          description: "Find emails from contact",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list",
          inputSchema: { query: "string" },
          outputSchema: { emails: "array" },
          writesToState: false,
        },
        {
          id: "slack.contact.messages",
          name: "Search contact mentions",
          description: "Find Slack mentions",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_search_messages",
          inputSchema: { query: "string" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "contact-emails-table",
          name: "Email History",
          type: "table",
          source: { entity: "Email", statePath: "google.contact_emails" },
          fields: ["from", "subject", "snippet", "internalDate"],
          actions: ["google.gmail.contact"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.gmail.contact",
          query: { query: "from:{{contact}}" },
          fields: ["from", "subject", "snippet", "internalDate"],
          max_results: 20,
        },
      ],
      answer_contract: {
        entity_type: "email",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Build contact context",
        sub_goals: ["Find emails", "Find Slack mentions"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Contact context",
        integrations: ["google", "slack"],
        objects: ["Email", "Message"],
        successCriteria: ["Context compiled"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Email"], minimumRecords: 1 },
    }),
  },
  {
    id: "consumer-notion-knowledge-base",
    name: "Personal Knowledge Base Builder",
    description: "Organize and index your Notion pages into a searchable knowledge base.",
    category: "Personal (Consumer)",
    integrations: ["notion"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Index my Notion pages and create a searchable knowledge base.",
    spec: buildSpec({
      id: "consumer-notion-knowledge-base",
      name: "Personal Knowledge Base Builder",
      description: "Index Notion pages.",
      purpose: "Create searchable knowledge base.",
      integrations: ["notion"],
      entities: [notionPageEntity],
      actions: [
        {
          id: "notion.pages.all",
          name: "List all pages",
          description: "Fetch all Notion pages",
          type: "READ",
          integrationId: "notion",
          capabilityId: "notion_pages_search",
          inputSchema: { query: "string" },
          outputSchema: { pages: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "knowledge-base-table",
          name: "Knowledge Base",
          type: "table",
          source: { entity: "Page", statePath: "notion.all_pages" },
          fields: ["title", "lastEdited", "url"],
          actions: ["notion.pages.all"],
        },
      ],
      query_plans: [
        {
          integrationId: "notion",
          actionId: "notion.pages.all",
          query: { query: "" },
          fields: ["title", "lastEdited", "url"],
          max_results: 50,
        },
      ],
      answer_contract: {
        entity_type: "page",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Index knowledge base",
        sub_goals: ["List all pages", "Organize by topic"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Knowledge base",
        integrations: ["notion"],
        objects: ["Page"],
        successCriteria: ["Pages indexed"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Page"], minimumRecords: 1 },
    }),
  },
  // ===== ENTERPRISE-GRADE USE CASES =====
  {
    id: "enterprise-multi-repo-security",
    name: "Multi-Repo Security Scanner",
    description: "Scan multiple GitHub repos for security issues and vulnerabilities.",
    category: "Engineering",
    integrations: ["github"],
    trigger: "Time-based",
    output: "Table",
    prompt: "Scan all repositories for security issues and vulnerabilities.",
    spec: buildSpec({
      id: "enterprise-multi-repo-security",
      name: "Multi-Repo Security Scanner",
      description: "Scan repos for security issues.",
      purpose: "Identify security vulnerabilities across repos.",
      integrations: ["github"],
      entities: [githubIssueEntity],
      actions: [
        {
          id: "github.security.scan",
          name: "Search security issues",
          description: "Find security-labeled issues",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_issues_search",
          inputSchema: { query: "string" },
          outputSchema: { issues: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "security-scan-table",
          name: "Security Issues",
          type: "table",
          source: { entity: "Issue", statePath: "github.security" },
          fields: ["title", "state", "url"],
          actions: ["github.security.scan"],
        },
      ],
      query_plans: [
        {
          integrationId: "github",
          actionId: "github.security.scan",
          query: { q: "is:issue is:open label:security OR label:vulnerability" },
          fields: ["title", "state", "url"],
          max_results: 50,
        },
      ],
      answer_contract: {
        entity_type: "issue",
        required_constraints: [{ field: "labels", operator: "semantic_contains", value: "security" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Scan for security issues",
        sub_goals: ["Search all repos", "Find security labels"],
        constraints: ["Open issues"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Security scanning",
        integrations: ["github"],
        objects: ["Issue"],
        filters: ["security", "vulnerability"],
        successCriteria: ["Security issues found"],
        forbiddenOutputs: ["dummy"],
      }),
      triggers: [
        {
          id: "security-weekly",
          name: "Weekly security scan",
          type: "cron",
          condition: { cron: "0 9 * * MON" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 0 },
    }),
  },
  {
    id: "enterprise-sprint-retrospective",
    name: "Sprint Retrospective Generator",
    description: "Generate sprint retrospective from Linear issues and Slack discussions.",
    category: "Engineering",
    integrations: ["linear", "slack"],
    trigger: "Prompt-based",
    output: "Document",
    prompt: "Generate a sprint retrospective from completed issues and team discussions.",
    spec: buildSpec({
      id: "enterprise-sprint-retrospective",
      name: "Sprint Retrospective Generator",
      description: "Generate retrospective.",
      purpose: "Compile sprint retro from data.",
      integrations: ["linear", "slack"],
      entities: [linearIssueEntity, slackMessageEntity],
      actions: [
        {
          id: "linear.sprint.completed",
          name: "List completed issues",
          description: "Get completed sprint issues",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list",
          inputSchema: {},
          outputSchema: { issues: "array" },
          writesToState: false,
        },
        {
          id: "slack.retro.discussions",
          name: "Search retro discussions",
          description: "Find sprint discussions",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_search_messages",
          inputSchema: { query: "string" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "sprint-completed-table",
          name: "Completed Issues",
          type: "table",
          source: { entity: "Issue", statePath: "linear.completed" },
          fields: ["title", "state", "assignee"],
          actions: ["linear.sprint.completed"],
        },
      ],
      query_plans: [
        {
          integrationId: "linear",
          actionId: "linear.sprint.completed",
          query: {},
          fields: ["title", "state", "assignee"],
          max_results: 50,
        },
        {
          integrationId: "slack",
          actionId: "slack.retro.discussions",
          query: { query: "sprint OR retrospective OR blocker" },
          fields: ["channel", "user", "text"],
          max_results: 30,
        },
      ],
      answer_contract: {
        entity_type: "issue",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Generate retrospective",
        sub_goals: ["List completed work", "Gather feedback"],
        constraints: ["Current sprint"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Sprint retrospective",
        integrations: ["linear", "slack"],
        objects: ["Issue", "Message"],
        successCriteria: ["Retro generated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-customer-escalation",
    name: "Customer Escalation Intelligence",
    description: "Detect and track customer escalations across Slack and email.",
    category: "Operations",
    integrations: ["slack", "google"],
    trigger: "Event-based",
    output: "Alert",
    prompt: "Detect customer escalations from Slack and email.",
    spec: buildSpec({
      id: "enterprise-customer-escalation",
      name: "Customer Escalation Intelligence",
      description: "Detect escalations.",
      purpose: "Track customer escalations.",
      integrations: ["slack", "google"],
      entities: [slackMessageEntity, emailEntity],
      actions: [
        {
          id: "slack.escalation.detect",
          name: "Search escalations",
          description: "Find escalation messages",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_search_messages",
          inputSchema: { query: "string" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
        {
          id: "google.gmail.escalation",
          name: "Search escalation emails",
          description: "Find escalation emails",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list",
          inputSchema: { query: "string" },
          outputSchema: { emails: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "escalation-slack-table",
          name: "Slack Escalations",
          type: "table",
          source: { entity: "Message", statePath: "slack.escalations" },
          fields: ["channel", "user", "text", "timestamp"],
          actions: ["slack.escalation.detect"],
        },
      ],
      query_plans: [
        {
          integrationId: "slack",
          actionId: "slack.escalation.detect",
          query: { query: "escalation OR urgent OR critical OR P0" },
          fields: ["channel", "user", "text", "timestamp"],
          max_results: 25,
        },
        {
          integrationId: "google",
          actionId: "google.gmail.escalation",
          query: { query: "escalation OR urgent newer_than:7d" },
          fields: ["from", "subject", "snippet"],
          max_results: 20,
        },
      ],
      answer_contract: {
        entity_type: "message",
        required_constraints: [{ field: "text", operator: "semantic_contains", value: "escalation" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Detect escalations",
        sub_goals: ["Search Slack", "Search email"],
        constraints: ["Recent"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Customer escalation detection",
        integrations: ["slack", "google"],
        objects: ["Message", "Email"],
        filters: ["escalation", "urgent"],
        successCriteria: ["Escalations detected"],
        forbiddenOutputs: ["dummy"],
      }),
      triggers: [
        {
          id: "escalation-event",
          name: "Escalation trigger",
          type: "integration_event",
          condition: { event: "message_posted", keyword: "escalation" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["Message"], minimumRecords: 0 },
    }),
  },
  {
    id: "enterprise-compliance-audit",
    name: "Compliance Audit Trail Builder",
    description: "Build audit trails from documents and communications.",
    category: "Operations",
    integrations: ["google", "slack"],
    trigger: "Prompt-based",
    output: "Document",
    prompt: "Build a compliance audit trail for {{topic}}.",
    spec: buildSpec({
      id: "enterprise-compliance-audit",
      name: "Compliance Audit Trail Builder",
      description: "Build audit trails.",
      purpose: "Compile compliance documentation.",
      integrations: ["google", "slack"],
      entities: [driveFileEntity, slackMessageEntity],
      actions: [
        {
          id: "google.drive.compliance",
          name: "Search compliance docs",
          description: "Find compliance documents",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_drive_list",
          inputSchema: { query: "string" },
          outputSchema: { files: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "compliance-docs-table",
          name: "Compliance Documents",
          type: "table",
          source: { entity: "File", statePath: "google.compliance" },
          fields: ["name", "modifiedTime", "webViewLink"],
          actions: ["google.drive.compliance"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.drive.compliance",
          query: { q: "name contains 'compliance' or name contains 'audit'" },
          fields: ["name", "modifiedTime", "webViewLink"],
          max_results: 30,
        },
      ],
      answer_contract: {
        entity_type: "file",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Build audit trail",
        sub_goals: ["Find compliance docs", "Gather communications"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Compliance audit",
        integrations: ["google", "slack"],
        objects: ["File", "Message"],
        filters: ["compliance", "audit"],
        successCriteria: ["Audit trail compiled"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["File"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-incident-postmortem",
    name: "Incident Postmortem Generator",
    description: "Generate incident postmortems from Slack and GitHub data.",
    category: "Engineering",
    integrations: ["slack", "github"],
    trigger: "Prompt-based",
    output: "Document",
    prompt: "Generate an incident postmortem for the recent outage.",
    spec: buildSpec({
      id: "enterprise-incident-postmortem",
      name: "Incident Postmortem Generator",
      description: "Generate postmortems.",
      purpose: "Compile incident postmortem.",
      integrations: ["slack", "github"],
      entities: [slackMessageEntity, githubIssueEntity],
      actions: [
        {
          id: "slack.incident.messages",
          name: "Search incident messages",
          description: "Find incident discussion",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_search_messages",
          inputSchema: { query: "string" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
        {
          id: "github.incident.issues",
          name: "Search incident issues",
          description: "Find incident issues",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_issues_search",
          inputSchema: { query: "string" },
          outputSchema: { issues: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "incident-timeline",
          name: "Incident Timeline",
          type: "table",
          source: { entity: "Message", statePath: "slack.incident" },
          fields: ["channel", "user", "text", "timestamp"],
          actions: ["slack.incident.messages"],
        },
      ],
      query_plans: [
        {
          integrationId: "slack",
          actionId: "slack.incident.messages",
          query: { query: "incident OR outage OR postmortem in:#incidents" },
          fields: ["channel", "user", "text", "timestamp"],
          max_results: 50,
        },
        {
          integrationId: "github",
          actionId: "github.incident.issues",
          query: { q: "is:issue label:incident OR label:postmortem" },
          fields: ["title", "state", "url"],
          max_results: 20,
        },
      ],
      answer_contract: {
        entity_type: "message",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Generate postmortem",
        sub_goals: ["Gather incident data", "Build timeline"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Incident postmortem",
        integrations: ["slack", "github"],
        objects: ["Message", "Issue"],
        filters: ["incident", "outage"],
        successCriteria: ["Postmortem generated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Message"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-release-readiness",
    name: "Release Readiness Assessment",
    description: "Assess release readiness based on open issues and blockers.",
    category: "Engineering",
    integrations: ["github", "linear"],
    trigger: "Prompt-based",
    output: "Summary",
    prompt: "Assess release readiness for the upcoming release.",
    spec: buildSpec({
      id: "enterprise-release-readiness",
      name: "Release Readiness Assessment",
      description: "Assess release readiness.",
      purpose: "Check blocker issues before release.",
      integrations: ["github", "linear"],
      entities: [githubIssueEntity, linearIssueEntity],
      actions: [
        {
          id: "github.release.blockers",
          name: "Find release blockers",
          description: "Search for blockers",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_issues_search",
          inputSchema: { query: "string" },
          outputSchema: { issues: "array" },
          writesToState: false,
        },
        {
          id: "linear.release.blockers",
          name: "Find Linear blockers",
          description: "Search Linear blockers",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list",
          inputSchema: {},
          outputSchema: { issues: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "release-blockers-table",
          name: "Release Blockers",
          type: "table",
          source: { entity: "Issue", statePath: "github.blockers" },
          fields: ["title", "state", "url"],
          actions: ["github.release.blockers"],
        },
      ],
      query_plans: [
        {
          integrationId: "github",
          actionId: "github.release.blockers",
          query: { q: "is:issue is:open label:blocker OR label:release-blocker" },
          fields: ["title", "state", "url"],
          max_results: 30,
        },
        {
          integrationId: "linear",
          actionId: "linear.release.blockers",
          query: {},
          fields: ["title", "state", "priority"],
          max_results: 30,
        },
      ],
      answer_contract: {
        entity_type: "issue",
        required_constraints: [{ field: "labels", operator: "semantic_contains", value: "blocker" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Assess release readiness",
        sub_goals: ["Find blockers", "Check high priority issues"],
        constraints: ["Open issues"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Release readiness",
        integrations: ["github", "linear"],
        objects: ["Issue"],
        filters: ["blocker", "release"],
        successCriteria: ["Readiness assessed"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 0 },
    }),
  },
  {
    id: "enterprise-team-blocker-detector",
    name: "Cross-Team Blocker Detector",
    description: "Detect blockers affecting multiple teams.",
    category: "Operations",
    integrations: ["linear", "slack"],
    trigger: "Time-based",
    output: "Table",
    prompt: "Detect blockers affecting multiple teams.",
    spec: buildSpec({
      id: "enterprise-team-blocker-detector",
      name: "Cross-Team Blocker Detector",
      description: "Detect cross-team blockers.",
      purpose: "Identify blockers across teams.",
      integrations: ["linear", "slack"],
      entities: [linearIssueEntity, slackMessageEntity],
      actions: [
        {
          id: "linear.blockers.all",
          name: "List all blockers",
          description: "Get blocker issues",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list",
          inputSchema: {},
          outputSchema: { issues: "array" },
          writesToState: false,
        },
        {
          id: "slack.blockers.mentions",
          name: "Search blocker mentions",
          description: "Find blocker discussions",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_search_messages",
          inputSchema: { query: "string" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "blockers-table",
          name: "Team Blockers",
          type: "table",
          source: { entity: "Issue", statePath: "linear.blockers" },
          fields: ["title", "state", "assignee", "priority"],
          actions: ["linear.blockers.all"],
        },
      ],
      query_plans: [
        {
          integrationId: "linear",
          actionId: "linear.blockers.all",
          query: {},
          fields: ["title", "state", "assignee", "priority"],
          max_results: 40,
        },
        {
          integrationId: "slack",
          actionId: "slack.blockers.mentions",
          query: { query: "blocked OR blocker OR waiting on" },
          fields: ["channel", "user", "text"],
          max_results: 30,
        },
      ],
      answer_contract: {
        entity_type: "issue",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Detect team blockers",
        sub_goals: ["Find Linear blockers", "Find Slack mentions"],
        constraints: ["Current"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Cross-team blockers",
        integrations: ["linear", "slack"],
        objects: ["Issue", "Message"],
        filters: ["blocker"],
        successCriteria: ["Blockers detected"],
        forbiddenOutputs: ["dummy"],
      }),
      triggers: [
        {
          id: "blocker-daily",
          name: "Daily blocker check",
          type: "cron",
          condition: { cron: "0 9 * * 1-5" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 0 },
    }),
  },
  {
    id: "enterprise-pr-review-queue",
    name: "PR Review Queue Manager",
    description: "Manage and prioritize pending PR reviews across repos.",
    category: "Engineering",
    integrations: ["github"],
    trigger: "Time-based",
    output: "Table",
    prompt: "Show me all pending PR reviews prioritized by age.",
    spec: buildSpec({
      id: "enterprise-pr-review-queue",
      name: "PR Review Queue Manager",
      description: "Manage PR reviews.",
      purpose: "Prioritize PR reviews.",
      integrations: ["github"],
      entities: [githubIssueEntity],
      actions: [
        {
          id: "github.prs.pending",
          name: "List pending PRs",
          description: "Get open PRs",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_issues_search",
          inputSchema: { query: "string" },
          outputSchema: { issues: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "pr-queue-table",
          name: "PR Review Queue",
          type: "table",
          source: { entity: "Issue", statePath: "github.prs" },
          fields: ["title", "state", "url"],
          actions: ["github.prs.pending"],
        },
      ],
      query_plans: [
        {
          integrationId: "github",
          actionId: "github.prs.pending",
          query: { q: "is:pr is:open review:required sort:created-asc" },
          fields: ["title", "state", "url"],
          max_results: 40,
        },
      ],
      answer_contract: {
        entity_type: "issue",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Manage PR queue",
        sub_goals: ["List pending PRs", "Sort by age"],
        constraints: ["Open PRs"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "PR review queue",
        integrations: ["github"],
        objects: ["Issue"],
        filters: ["pr", "review"],
        successCriteria: ["PRs listed"],
        forbiddenOutputs: ["dummy"],
      }),
      triggers: [
        {
          id: "pr-daily",
          name: "Daily PR digest",
          type: "cron",
          condition: { cron: "0 9 * * 1-5" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 0 },
    }),
  },
  {
    id: "enterprise-stakeholder-comms",
    name: "Stakeholder Communication Intelligence",
    description: "Track and summarize stakeholder communications.",
    category: "Leadership / Exec",
    integrations: ["google", "slack"],
    trigger: "Prompt-based",
    output: "Summary",
    prompt: "Summarize recent communications with key stakeholders.",
    spec: buildSpec({
      id: "enterprise-stakeholder-comms",
      name: "Stakeholder Communication Intelligence",
      description: "Track stakeholder comms.",
      purpose: "Summarize stakeholder interactions.",
      integrations: ["google", "slack"],
      entities: [emailEntity, slackMessageEntity],
      actions: [
        {
          id: "google.gmail.stakeholder",
          name: "Search stakeholder emails",
          description: "Find stakeholder emails",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list",
          inputSchema: { query: "string" },
          outputSchema: { emails: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "stakeholder-emails-table",
          name: "Stakeholder Emails",
          type: "table",
          source: { entity: "Email", statePath: "google.stakeholders" },
          fields: ["from", "subject", "snippet", "internalDate"],
          actions: ["google.gmail.stakeholder"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.gmail.stakeholder",
          query: { query: "newer_than:14d (board OR investor OR advisor)" },
          fields: ["from", "subject", "snippet", "internalDate"],
          max_results: 25,
        },
      ],
      answer_contract: {
        entity_type: "email",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Summarize stakeholder comms",
        sub_goals: ["Find stakeholder emails", "Analyze themes"],
        constraints: ["Recent"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Stakeholder communications",
        integrations: ["google", "slack"],
        objects: ["Email", "Message"],
        filters: ["stakeholder", "board"],
        successCriteria: ["Comms summarized"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Email"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-onboarding-tracker",
    name: "Employee Onboarding Tracker",
    description: "Track new employee onboarding progress across Notion and Slack.",
    category: "Operations",
    integrations: ["notion", "slack"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Track onboarding progress for new employees.",
    spec: buildSpec({
      id: "enterprise-onboarding-tracker",
      name: "Employee Onboarding Tracker",
      description: "Track onboarding.",
      purpose: "Monitor onboarding progress.",
      integrations: ["notion", "slack"],
      entities: [notionPageEntity, slackMessageEntity],
      actions: [
        {
          id: "notion.onboarding.pages",
          name: "Search onboarding pages",
          description: "Find onboarding docs",
          type: "READ",
          integrationId: "notion",
          capabilityId: "notion_pages_search",
          inputSchema: { query: "string" },
          outputSchema: { pages: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "onboarding-table",
          name: "Onboarding Progress",
          type: "table",
          source: { entity: "Page", statePath: "notion.onboarding" },
          fields: ["title", "lastEdited", "url"],
          actions: ["notion.onboarding.pages"],
        },
      ],
      query_plans: [
        {
          integrationId: "notion",
          actionId: "notion.onboarding.pages",
          query: { query: "onboarding OR new hire" },
          fields: ["title", "lastEdited", "url"],
          max_results: 20,
        },
      ],
      answer_contract: {
        entity_type: "page",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Track onboarding",
        sub_goals: ["Find onboarding pages"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Onboarding tracking",
        integrations: ["notion", "slack"],
        objects: ["Page", "Message"],
        filters: ["onboarding"],
        successCriteria: ["Progress tracked"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Page"], minimumRecords: 1 },
    }),
  },
];

export const useCaseCategories: UseCaseCategory[] = [
  "Featured",
  "Engineering",
  "Design",
  "Marketing",
  "Sales",
  "Operations",
  "Leadership / Exec",
  "Personal (Consumer)",
];

export const useCasesByCategory = useCaseCategories.map((category) => ({
  category,
  items: useCases.filter((tool) => tool.category === category),
}));

export { useCases };
