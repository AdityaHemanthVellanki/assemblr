import { createEmptyToolSpec, type IntegrationId, type ToolSystemSpec } from "@/lib/toolos/spec";
import { getCapabilitiesForIntegration } from "@/lib/capabilities/registry";

export type UseCaseCategory =
  | "Engineering & Product"
  | "Revenue, Sales & CRM"
  | "Customer Support & Success"
  | "Operations & Finance"
  | "Executive & Leadership"
  | "Internal Productivity";

export type UseCaseTrigger = "Prompt-based" | "Event-based" | "Time-based";
export type UseCaseOutput = "Table" | "Summary" | "Alert" | "Document";

export type UseCaseDefinition = {
  id: string;
  name: string;
  description: string;
  category: UseCaseCategory;
  integrations: IntegrationId[];
  trigger: UseCaseTrigger;
  output: UseCaseOutput;
  prompt: string;
  spec: ToolSystemSpec;
};

const integrationCapabilities = (id: IntegrationId) =>
  getCapabilitiesForIntegration(id).map((cap) => cap.id);

const buildSpec = (input: {
  id: string;
  name: string;
  description: string;
  purpose: string;
  integrations: IntegrationId[];
  entities: ToolSystemSpec["entities"];
  actions: ToolSystemSpec["actions"];
  views: ToolSystemSpec["views"];
  query_plans: ToolSystemSpec["query_plans"];
  answer_contract: ToolSystemSpec["answer_contract"];
  goal_plan: ToolSystemSpec["goal_plan"];
  intent_contract: ToolSystemSpec["intent_contract"];
  triggers?: ToolSystemSpec["triggers"];
  initialFetch?: ToolSystemSpec["initialFetch"];
  dataReadiness?: ToolSystemSpec["dataReadiness"];
}) => {
  const base = createEmptyToolSpec({
    id: input.id,
    name: input.name,
    purpose: input.purpose,
    description: input.description,
    sourcePrompt: input.purpose,
  });

  return {
    ...base,
    integrations: input.integrations.map((id) => ({
      id,
      capabilities: integrationCapabilities(id),
    })),
    entities: input.entities,
    actions: input.actions,
    views: input.views,
    triggers: input.triggers ?? [],
    query_plans: input.query_plans,
    answer_contract: input.answer_contract,
    goal_plan: input.goal_plan,
    intent_contract: input.intent_contract,
    initialFetch: input.initialFetch,
    dataReadiness: input.dataReadiness,
    automations: {
      enabled: true,
      capabilities: {
        canRunWithoutUI: true,
        supportedTriggers: (input.triggers ?? []).map((t) => t.type),
        maxFrequency: 1440,
        safetyConstraints: ["approval_required_for_writes"],
      },
    },
    observability: {
      executionTimeline: true,
      recentRuns: true,
      errorStates: true,
      integrationHealth: true,
      manualRetryControls: true,
    },
  };
};

const buildIntentContract = (input: {
  userGoal: string;
  integrations: string[];
  objects?: string[];
  filters?: string[];
  successCriteria?: string[];
  forbiddenOutputs?: string[];
}) => ({
  userGoal: input.userGoal,
  successCriteria: input.successCriteria ?? [],
  implicitConstraints: [],
  hiddenStateRequirements: [],
  subjectivityScore: 0.35,
  heuristics: [],
  requiredEntities: {
    integrations: input.integrations,
    objects: input.objects ?? [],
    filters: input.filters ?? [],
  },
  forbiddenOutputs: input.forbiddenOutputs ?? [],
  acceptableFallbacks: [],
});

const githubIssueEntity = {
  name: "Issue",
  sourceIntegration: "github" as const,
  identifiers: ["id", "number"],
  supportedActions: ["github.issues.search", "github.issues.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "number", type: "number" },
    { name: "title", type: "string" },
    { name: "state", type: "string" },
    { name: "url", type: "string" },
  ],
};

const linearIssueEntity = {
  name: "Issue",
  sourceIntegration: "linear" as const,
  identifiers: ["id"],
  supportedActions: ["linear.issues.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "title", type: "string" },
    { name: "state", type: "string" },
    { name: "assignee", type: "string" },
    { name: "priority", type: "number" },
  ],
};

const githubPREntity = {
  name: "PullRequest",
  sourceIntegration: "github" as const,
  identifiers: ["id", "number"],
  supportedActions: ["github.pull_requests.search"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "title", type: "string" },
    { name: "url", type: "string" },
    { name: "state", type: "string" },
    { name: "mergedAt", type: "string" },
  ],
};

const notionPageEntity = {
  name: "Page",
  sourceIntegration: "notion" as const,
  identifiers: ["id"],
  supportedActions: ["notion.pages.search"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "title", type: "string" },
    { name: "url", type: "string" },
    { name: "content", type: "string" },
  ],
};

const slackMessageEntity = {
  name: "Message",
  sourceIntegration: "slack" as const,
  identifiers: ["id", "timestamp"],
  supportedActions: ["slack.messages.search"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "text", type: "string" },
    { name: "channel", type: "string" },
    { name: "timestamp", type: "string" },
  ],
};

const gitlabProjectEntity = {
  name: "Project",
  sourceIntegration: "gitlab" as const,
  identifiers: ["id"],
  supportedActions: ["gitlab.projects.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "name", type: "string" },
    { name: "path_with_namespace", type: "string" },
  ],
};

const googleAnalyticsReportEntity = {
  name: "Report",
  sourceIntegration: "google_analytics" as const,
  identifiers: ["propertyId"],
  supportedActions: ["google_analytics.reports.run"],
  fields: [
    { name: "metricHeaders", type: "array" },
    { name: "rows", type: "array" },
  ],
};

const emailEntity = {
  name: "Email",
  sourceIntegration: "google" as const,
  identifiers: ["id", "threadId"],
  supportedActions: ["google.gmail.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "from", type: "string" },
    { name: "subject", type: "string" },
    { name: "snippet", type: "string" },
    { name: "internalDate", type: "string" },
    { name: "labelIds", type: "array" },
  ],
};

const hubspotDealEntity = {
  name: "Deal",
  sourceIntegration: "hubspot" as const,
  identifiers: ["id"],
  supportedActions: ["hubspot.deals.list"],
  fields: [
    { name: "dealname", type: "string" },
    { name: "amount", type: "number" },
    { name: "dealstage", type: "string" },
    { name: "closedate", type: "string" },
  ],
};

const stripeChargeEntity = {
  name: "Charge",
  sourceIntegration: "stripe" as const,
  identifiers: ["id"],
  supportedActions: ["stripe.charges.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "amount", type: "number" },
    { name: "currency", type: "string" },
    { name: "status", type: "string" },
    { name: "created", type: "number" },
  ],
};

const intercomConversationEntity = {
  name: "Conversation",
  sourceIntegration: "intercom" as const,
  identifiers: ["id"],
  supportedActions: ["intercom.conversations.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "source", type: "object" }, // { type: "email", author: ... }
    { name: "state", type: "string" }, // open, closed
    { name: "created_at", type: "number" },
  ],
};

const zendeskTicketEntity = {
  name: "Ticket",
  sourceIntegration: "zendesk" as const,
  identifiers: ["id"],
  supportedActions: ["zendesk.tickets.list"],
  fields: [
    { name: "id", type: "number", required: true },
    { name: "subject", type: "string" },
    { name: "status", type: "string" },
    { name: "priority", type: "string" },
  ],
};

const airtableRecordEntity = {
  name: "Record",
  sourceIntegration: "airtable" as const,
  identifiers: ["id"],
  supportedActions: ["airtable.records.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "fields", type: "object" },
    { name: "createdTime", type: "string" },
  ],
};

export const useCases: UseCaseDefinition[] = [
  // =================================================================
  // ENGINEERING & PRODUCT INTELLIGENCE
  // =================================================================
  {
    id: "eng-velocity-tracker",
    name: "Engineering Velocity Tracker",
    description: "Analyze sprint velocity and blockers by correlating GitHub PRs with Linear cycles.",
    category: "Engineering & Product",
    integrations: ["github", "linear"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Analyze our engineering velocity for the last 2 weeks using GitHub and Linear data.",
    spec: buildSpec({
      id: "eng-velocity-tracker",
      name: "Engineering Velocity Tracker",
      description: "Correlate PR velocity with Linear throughput.",
      purpose: "Identify delivery bottlenecks.",
      integrations: ["github", "linear"],
      entities: [githubPREntity, linearIssueEntity],
      actions: [
        {
          id: "github.pr.merged.recent",
          name: "Fetch recent merged PRs",
          description: "Get PRs merged in last 14 days",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_pull_requests_search",
          inputSchema: { q: "string" },
          outputSchema: { items: "array" },
          writesToState: false,
        },
        {
          id: "linear.issues.completed",
          name: "Fetch completed Linear issues",
          description: "Get issues completed in recent cycles",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list",
          inputSchema: { completedAfter: "string" },
          outputSchema: { nodes: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "velocity-view",
          name: "Velocity Correlations",
          type: "table",
          source: { entity: "PullRequest", statePath: "github.prs" },
          fields: ["title", "mergedAt", "author"],
          actions: ["github.pr.merged.recent"],
        },
      ],
      query_plans: [
        {
          integrationId: "github",
          actionId: "github.pr.merged.recent",
          query: { q: "is:pr is:merged merged:>2023-01-01" }, // Dynamic date handling in real runtime
          fields: ["title", "merged_at"],
        },
        {
          integrationId: "linear",
          actionId: "linear.issues.completed",
          query: { completedAfter: "2023-01-01" },
          fields: ["title", "completedAt"],
        },
      ],
      answer_contract: {
        entity_type: "item",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Calculate velocity metrics",
        sub_goals: ["Count merged PRs", "Count completed issues", "Compare trends"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Track engineering velocity",
        integrations: ["github", "linear"],
        objects: ["PullRequest", "Issue"],
        successCriteria: ["Velocity metrics generated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["PullRequest", "Issue"], minimumRecords: 5 },
    }),
  },
  {
    id: "eng-release-readiness",
    name: "Enterprise Release Radar",
    description: "Holistic view of release blockers across GitHub, GitLab, and Linear.",
    category: "Engineering & Product",
    integrations: ["github", "gitlab", "linear"],
    trigger: "Prompt-based",
    output: "Summary",
    prompt: "Are we ready to release? Check all critical repos for blockers and open Linear bugs.",
    spec: buildSpec({
      id: "eng-release-readiness",
      name: "Enterprise Release Radar",
      description: "Cross-platform release readiness check.",
      purpose: "Prevent bad releases by aggregating blockers.",
      integrations: ["github", "gitlab", "linear"],
      entities: [githubIssueEntity, gitlabProjectEntity, linearIssueEntity],
      actions: [
        {
          id: "github.issues.blockers",
          name: "Find GitHub blockers",
          description: "Search for open issues with label 'blocker'",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_issues_search",
          inputSchema: { q: "string" },
          outputSchema: { items: "array" },
          writesToState: false,
        },
        {
          id: "gitlab.projects.ci",
          name: "Check GitLab CI status",
          description: "List projects to check pipeline status",
          type: "READ",
          integrationId: "gitlab",
          capabilityId: "gitlab_projects_list",
          inputSchema: { membership: "boolean" },
          outputSchema: { projects: "array" },
          writesToState: false,
        },
        {
          id: "linear.bugs.critical",
          name: "Find critical Linear bugs",
          description: "List high-priority open bugs",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list",
          inputSchema: { filter: "string" },
          outputSchema: { nodes: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "blockers-view",
          name: "Release Blockers",
          type: "table",
          source: { entity: "Issue", statePath: "github.blockers" },
          fields: ["title", "url"],
          actions: ["github.issues.blockers"],
        },
      ],
      query_plans: [
        {
          integrationId: "github",
          actionId: "github.issues.blockers",
          query: { q: "is:open label:blocker" },
          fields: ["title", "url"],
        },
        {
          integrationId: "linear",
          actionId: "linear.bugs.critical",
          query: { filter: 'priority "Urgent"' },
          fields: ["title", "priority"],
        },
      ],
      answer_contract: {
        entity_type: "blocker",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Assess release readiness",
        sub_goals: ["Identify GitHub blocking issues", "Check Linear urgent bugs", "Verify CI status"],
        constraints: ["Must be open items"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Determine release readiness",
        integrations: ["github", "gitlab", "linear"],
        objects: ["Issue", "Project"],
        successCriteria: ["Blocker list compiled"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 0 },
    }),
  },
  {
    id: "eng-incident-impact",
    name: "Incident Impact Analyzer",
    description: "Correlate Slack incident channels with recent deployments and customer tickets.",
    category: "Engineering & Product",
    integrations: ["slack", "github", "linear"],
    trigger: "Event-based",
    output: "Document",
    prompt: "Analyze the active incident channel #incidents-prod. Correlate with recent merges and reported bugs.",
    spec: buildSpec({
      id: "eng-incident-impact",
      name: "Incident Impact Analyzer",
      description: "Real-time incident context gathering.",
      purpose: "Speed up incident resolution.",
      integrations: ["slack", "github", "linear"],
      entities: [slackMessageEntity, githubPREntity, linearIssueEntity],
      actions: [
        {
          id: "slack.incident.activity",
          name: "Read incident channel",
          description: "Fetch recent messages from incident channel",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_messages_list",
          inputSchema: { channel: "string" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
        {
          id: "github.pr.recent",
          name: "Get recent deployments",
          description: "Fetch PRs merged in last 24h",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_pull_requests_search",
          inputSchema: { q: "string" },
          outputSchema: { items: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "impact-view",
          name: "Incident Context",
          type: "table",
          source: { entity: "Message", statePath: "slack.messages" },
          fields: ["text", "timestamp", "user"],
          actions: ["slack.incident.activity"],
        },
      ],
      query_plans: [
        {
          integrationId: "slack",
          actionId: "slack.incident.activity",
          query: { channel: "C12345" }, // Placeholder for dynamic resolution
          fields: ["text", "ts"],
        },
      ],
      answer_contract: {
        entity_type: "incident_context",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "object",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Provide incident context",
        sub_goals: ["Summarize slack chatter", "Identify suspect deployments"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Resolve incident faster",
        integrations: ["slack", "github"],
        objects: ["Message", "PullRequest"],
        successCriteria: ["Timeline correlated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Message"], minimumRecords: 1 },
    }),
  },
  {
    id: "eng-feature-adoption",
    name: "Feature Adoption vs Effort",
    description: "Compare engineering effort (Linear) against actual user adoption (Google Analytics).",
    category: "Engineering & Product",
    integrations: ["linear", "google_analytics"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Show me a comparison of our recent 'AI' features: effort spent vs usage traffic.",
    spec: buildSpec({
      id: "eng-feature-adoption",
      name: "Feature Adoption Analyzer",
      description: "ROI analysis for engineering features.",
      purpose: "Prioritize high-impact features.",
      integrations: ["linear", "google_analytics"],
      entities: [linearIssueEntity, googleAnalyticsReportEntity],
      actions: [
        {
          id: "linear.features.effort",
          name: "Get feature effort",
          description: "Fetch completed issues with 'AI' label",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list",
          inputSchema: { labels: "array" },
          outputSchema: { nodes: "array" },
          writesToState: false,
        },
        {
          id: "ga.traffic.usage",
          name: "Get usage metrics",
          description: "Run report for AI pages",
          type: "READ",
          integrationId: "google_analytics",
          capabilityId: "google_analytics_reports_run",
          inputSchema: { dateRanges: "array" },
          outputSchema: { rows: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "roi-view",
          name: "Feature ROI",
          type: "table",
          source: { entity: "Issue", statePath: "linear.features" },
          fields: ["title", "effort", "usage"],
          actions: ["linear.features.effort"],
        },
      ],
      query_plans: [
        {
          integrationId: "linear",
          actionId: "linear.features.effort",
          query: { labels: ["AI"] },
          fields: ["title", "estimate"],
        },
        {
          integrationId: "google_analytics",
          actionId: "ga.traffic.usage",
          query: { dateRanges: [{ startDate: "30daysAgo", endDate: "today" }] },
          fields: ["activeUsers"],
        },
      ],
      answer_contract: {
        entity_type: "feature_roi",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Analyze Feature ROI",
        sub_goals: ["Sum engineering estimate", "Get unique page views", "Calculate ratio"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Measure feature success",
        integrations: ["linear", "google_analytics"],
        objects: ["Issue", "Report"],
        successCriteria: ["ROI visualization"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Issue", "Report"], minimumRecords: 1 },
    }),
  },
  {
    id: "eng-cross-repo-deps",
    name: "Cross-Repo Dependency Map",
    description: "Map dependencies between GitHub services and Bitbucket libraries.",
    category: "Engineering & Product",
    integrations: ["github", "bitbucket"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Map out the dependencies between our GitHub microservices and Bitbucket core libraries.",
    spec: buildSpec({
      id: "eng-cross-repo-deps",
      name: "Cross-Repo Dependency Map",
      description: "Visualize cross-platform dependencies.",
      purpose: "Manage supply chain risk.",
      integrations: ["github", "bitbucket"],
      entities: [githubIssueEntity /* using issue/repo generic */],
      actions: [
        {
          id: "github.repos.list",
          name: "List GitHub Repos",
          description: "Fetch all active microservices",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_repos_list",
          inputSchema: { type: "string" },
          outputSchema: { items: "array" },
          writesToState: false,
        },
        {
          id: "bitbucket.repos.libs",
          name: "List Bitbucket Libs",
          description: "Fetch core libraries",
          type: "READ",
          integrationId: "bitbucket",
          capabilityId: "bitbucket_repos_list",
          inputSchema: { workspace: "string" },
          outputSchema: { values: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "dep-view",
          name: "Dependency Matrix",
          type: "table",
          source: { entity: "Repo", statePath: "github.repos" },
          fields: ["name", "dependencies"],
          actions: ["github.repos.list"],
        },
      ],
      query_plans: [
        {
          integrationId: "github",
          actionId: "github.repos.list",
          query: { type: "public" },
          fields: ["name", "full_name"],
        },
        {
          integrationId: "bitbucket",
          actionId: "bitbucket.repos.libs",
          query: { workspace: "assemblr-core" },
          fields: ["name", "slug"],
        },
      ],
      answer_contract: {
        entity_type: "dependency",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Map dependencies",
        sub_goals: ["List all services", "List all libs", "Match imports"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Map cross-repo dependencies",
        integrations: ["github", "bitbucket"],
        objects: ["Repository"],
        successCriteria: ["Dependency graph created"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Repository"], minimumRecords: 1 },
    }),
  },
  {
    id: "eng-sprint-retro",
    name: "Sprint Retrospective Generator",
    description: "Generate a data-driven retrospective based on Linear cycle completion and Slack sentiment.",
    category: "Engineering & Product",
    integrations: ["linear", "slack"],
    trigger: "Time-based",
    output: "Document",
    prompt: "Generate a retrospective for the last sprint using Linear data and team sentiment from Slack.",
    spec: buildSpec({
      id: "eng-sprint-retro",
      name: "Sprint Retrospective Generator",
      description: "Automated retro prep doc.",
      purpose: "Improve team reflection quality.",
      integrations: ["linear", "slack"],
      entities: [linearIssueEntity, slackMessageEntity],
      actions: [
        {
          id: "linear.cycle.stats",
          name: "Get cycle stats",
          description: "Fetch completion rate and rollover count",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_cycles_list",
          inputSchema: { includeArchived: "boolean" },
          outputSchema: { nodes: "array" },
          writesToState: false,
        },
        {
          id: "slack.channel.sentiment",
          name: "Analyze team channel",
          description: "Read last 2 weeks of general channel",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_messages_list",
          inputSchema: { channel: "string" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "retro-view",
          name: "Retro Context",
          type: "table",
          source: { entity: "Issue", statePath: "linear.cycle" },
          fields: ["id", "completion_rate"],
          actions: ["linear.cycle.stats"],
        },
      ],
      query_plans: [
        {
          integrationId: "linear",
          actionId: "linear.cycle.stats",
          query: { includeArchived: false },
          fields: ["number", "progress"],
        },
        {
          integrationId: "slack",
          actionId: "slack.channel.sentiment",
          query: { channel: "general" },
          fields: ["text"],
        },
      ],
      answer_contract: {
        entity_type: "retro_item",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "object",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Generate Retro",
        sub_goals: ["Calculate velocity misses", " summarize team mood"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Prepare retrospective",
        integrations: ["linear", "slack"],
        objects: ["Cycle", "Message"],
        successCriteria: ["Retro document generated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Cycle"], minimumRecords: 1 },
    }),
  },
  {
    id: "eng-pr-cycle-time",
    name: "PR Cycle Time Analyzer",
    description: "Deep dive into PR review times and bottleneck identification.",
    category: "Engineering & Product",
    integrations: ["github"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Identify the slowest stages in our PR review process for the last month.",
    spec: buildSpec({
      id: "eng-pr-cycle-time",
      name: "PR Cycle Time Analyzer",
      description: "Analyze code review latency.",
      purpose: "Optimize review velocity.",
      integrations: ["github"],
      entities: [githubPREntity],
      actions: [
        {
          id: "github.pr.reviews",
          name: "Fetch PR reviews",
          description: "Get review timestamps",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_pull_requests_search",
          inputSchema: { q: "string" },
          outputSchema: { items: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "cycle-time-view",
          name: "Cycle Times",
          type: "table",
          source: { entity: "PullRequest", statePath: "github.prs" },
          fields: ["title", "open_duration", "review_duration"],
          actions: ["github.pr.reviews"],
        },
      ],
      query_plans: [
        {
          integrationId: "github",
          actionId: "github.pr.reviews",
          query: { q: "is:pr is:merged merged:>30daysAgo" },
          fields: ["created_at", "closed_at"],
        },
      ],
      answer_contract: {
        entity_type: "pr_metric",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Analyze PR Latency",
        sub_goals: ["Calculate time to first review", "Calculate time to merge"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Optimize PR process",
        integrations: ["github"],
        objects: ["PullRequest"],
        successCriteria: ["Bottlenecks identified"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["PullRequest"], minimumRecords: 10 },
    }),
  },
  {
    id: "eng-daily-standup",
    name: "Automated Daily Standup",
    description: "Aggregate yesterday's commits, Linear updates, and Slack activity into a standup report.",
    category: "Engineering & Product",
    integrations: ["slack", "linear", "github"],
    trigger: "Time-based",
    output: "Summary",
    prompt: "Generate a standup report for the engineering team based on yesterday's activity.",
    spec: buildSpec({
      id: "eng-daily-standup",
      name: "Automated Daily Standup",
      description: "Auto-generate standup notes.",
      purpose: "Save meeting time.",
      integrations: ["slack", "linear", "github"],
      entities: [githubIssueEntity, linearIssueEntity, slackMessageEntity],
      actions: [
        {
          id: "user.activity.github",
          name: "Get commits",
          description: "Fetch yesterday's commits",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_commits_list",
          inputSchema: { since: "string" },
          outputSchema: { items: "array" },
          writesToState: false,
        },
        {
          id: "user.activity.linear",
          name: "Get issue updates",
          description: "Fetch issues updated yesterday",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list",
          inputSchema: { updatedAfter: "string" },
          outputSchema: { nodes: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "standup-view",
          name: "Yesterday's Work",
          type: "table",
          source: { entity: "Issue", statePath: "linear.updates" },
          fields: ["title", "state"],
          actions: ["user.activity.linear"],
        },
      ],
      query_plans: [
        {
          integrationId: "github",
          actionId: "user.activity.github",
          query: { since: "yesterday" },
          fields: ["commit.message", "author.name"],
        },
        {
          integrationId: "linear",
          actionId: "user.activity.linear",
          query: { updatedAfter: "yesterday" },
          fields: ["title", "state.name"],
        },
      ],
      answer_contract: {
        entity_type: "standup_item",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Generate Standup",
        sub_goals: ["Aggregate work items", "Group by user"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Automate standup",
        integrations: ["github", "linear", "slack"],
        objects: ["Commit", "Issue"],
        successCriteria: ["Standup summary created"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 1 },
    }),
  },
  {
    id: "eng-qa-coverage",
    name: "QA Test Coverage Monitor",
    description: "Identify features in Linear that lack corresponding test cases or QA sign-off in GitHub.",
    category: "Engineering & Product",
    integrations: ["linear", "github"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Find all 'Done' features in Linear that do not have a linked QA issue in GitHub.",
    spec: buildSpec({
      id: "eng-qa-coverage",
      name: "QA Test Coverage Monitor",
      description: "Ensure features are tested.",
      purpose: "Prevent regressions.",
      integrations: ["linear", "github"],
      entities: [linearIssueEntity, githubIssueEntity],
      actions: [
        {
          id: "linear.features.done",
          name: "Get shipped features",
          description: "Fetch recently completed features",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list",
          inputSchema: { filter: "string" },
          outputSchema: { nodes: "array" },
          writesToState: false,
        },
        {
          id: "github.qa.issues",
          name: "Get QA tasks",
          description: "Fetch QA issues",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_issues_search",
          inputSchema: { q: "string" },
          outputSchema: { items: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "coverage-view",
          name: "Test Coverage",
          type: "table",
          source: { entity: "Issue", statePath: "linear.features" },
          fields: ["title", "has_qa"],
          actions: ["linear.features.done"],
        },
      ],
      query_plans: [
        {
          integrationId: "linear",
          actionId: "linear.features.done",
          query: { filter: 'state.name "Done"' },
          fields: ["title", "url"],
        },
        {
          integrationId: "github",
          actionId: "github.qa.issues",
          query: { q: "label:QA" },
          fields: ["title", "body"],
        },
      ],
      answer_contract: {
        entity_type: "coverage_gap",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Check QA Coverage",
        sub_goals: ["List features", "List QA tasks", "Find gaps"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Ensure QA coverage",
        integrations: ["linear", "github"],
        objects: ["Issue"],
        successCriteria: ["Untested features listed"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 1 },
    }),
  },
  {
    id: "eng-tech-debt",
    name: "Technical Debt Forecast",
    description: "Predict technical debt accumulation by analyzing 'refactor' tickets and TODO comments.",
    category: "Engineering & Product",
    integrations: ["linear", "github"],
    trigger: "Prompt-based",
    output: "Summary",
    prompt: "Forecast our technical debt load based on open 'refactor' tickets and codebase TODO density.",
    spec: buildSpec({
      id: "eng-tech-debt",
      name: "Technical Debt Forecast",
      description: "Quantify technical debt.",
      purpose: "Justify refactoring sprints.",
      integrations: ["linear", "github"],
      entities: [linearIssueEntity, githubIssueEntity],
      actions: [
        {
          id: "linear.debt.issues",
          name: "Get debt tickets",
          description: "Fetch issues with 'Refactor' or 'Debt' labels",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list",
          inputSchema: { labels: "array" },
          outputSchema: { nodes: "array" },
          writesToState: false,
        },
        {
          id: "github.todos",
          name: "Search TODOs",
          description: "Search code for TODO",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_issues_search", // Proxying code search via issue search for now, or assume code search cap exists
          inputSchema: { q: "string" },
          outputSchema: { items: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "debt-view",
          name: "Debt Profile",
          type: "detail",
          source: { entity: "Issue", statePath: "linear.debt" },
          fields: ["count", "growth_rate"],
          actions: ["linear.debt.issues"],
        },
      ],
      query_plans: [
        {
          integrationId: "linear",
          actionId: "linear.debt.issues",
          query: { labels: ["Refactor", "Tech Debt"] },
          fields: ["title", "created_at"],
        },
        {
          integrationId: "github",
          actionId: "github.todos",
          query: { q: "TODO in:file" },
          fields: ["total_count"],
        },
      ],
      answer_contract: {
        entity_type: "debt_metric",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "object",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Forecast Debt",
        sub_goals: ["Count debt tickets", "Estimate code rot", "Project growth"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Manage technical debt",
        integrations: ["linear", "github"],
        objects: ["Issue"],
        successCriteria: ["Debt forecast created"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 1 },
    }),
  },
  // =================================================================
  // REVENUE, SALES & CRM SYSTEMS
  // =================================================================
  {
    id: "rev-revenue-forecast",
    name: "Revenue Forecasting Engine",
    description: "Combine HubSpot deal pipeline data with Stripe active subscriptions to forecast Q3 revenue.",
    category: "Revenue, Sales & CRM",
    integrations: ["hubspot", "stripe"],
    trigger: "Time-based",
    output: "Table",
    prompt: "generate a revenue forecast for Q3 merging HubSpot deal probabilities and Stripe MRR chrun rates.",
    spec: buildSpec({
      id: "rev-revenue-forecast",
      name: "Revenue Forecasting Engine",
      description: "Predict future revenue.",
      purpose: "Accurate financial planning.",
      integrations: ["hubspot", "stripe"],
      entities: [hubspotDealEntity, stripeChargeEntity],
      actions: [
        {
          id: "hubspot.deals.pipeline",
          name: "Fetch active deals",
          description: "Get deals closing next quarter",
          type: "READ",
          integrationId: "hubspot",
          capabilityId: "hubspot_deals_list",
          inputSchema: { properties: "array" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
        {
          id: "stripe.subs.mrr",
          name: "Get MRR data",
          description: "Fetch active subscriptions",
          type: "READ",
          integrationId: "stripe",
          capabilityId: "stripe_charges_list", // Proxying via charges or assume subs cap exists
          inputSchema: { limit: "number" },
          outputSchema: { data: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "forecast-view",
          name: "Q3 Projection",
          type: "table",
          source: { entity: "Deal", statePath: "hubspot.deals" },
          fields: ["dealname", "amount", "probability", "weighted_value"],
          actions: ["hubspot.deals.pipeline"],
        },
      ],
      query_plans: [
        {
          integrationId: "hubspot",
          actionId: "hubspot.deals.pipeline",
          query: { properties: ["amount", "dealstage", "closedate"] },
          fields: ["amount", "dealstage"],
        },
        {
          integrationId: "stripe",
          actionId: "stripe.subs.mrr",
          query: { limit: 100 },
          fields: ["amount", "status"],
        },
      ],
      answer_contract: {
        entity_type: "forecast_item",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Forecast Revenue",
        sub_goals: ["Sum weighted pipeline", "Project existing MRR", "Subtract churn"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Forecast revenue",
        integrations: ["hubspot", "stripe"],
        objects: ["Deal", "Charge"],
        successCriteria: ["Revenue forecast table"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Deal", "Charge"], minimumRecords: 10 },
    }),
  },
  {
    id: "rev-deal-health",
    name: "Deal Health Predictor",
    description: "Identify stale deals in HubSpot that haven't had email activity in 14 days.",
    category: "Revenue, Sales & CRM",
    integrations: ["hubspot", "google"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Find all deals >$10k in HubSpot that haven't had any email activity in the last 2 weeks.",
    spec: buildSpec({
      id: "rev-deal-health",
      name: "Deal Health Predictor",
      description: "Spot at-risk deals.",
      purpose: "Prevent slipped deals.",
      integrations: ["hubspot", "google"],
      entities: [hubspotDealEntity, emailEntity],
      actions: [
        {
          id: "hubspot.deals.open",
          name: "Get open deals",
          description: "Fetch non-closed deals",
          type: "READ",
          integrationId: "hubspot",
          capabilityId: "hubspot_deals_list",
          inputSchema: { properties: "array" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
        {
          id: "google.search.emails",
          name: "Check email threads",
          description: "Search emails from deal contacts",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list",
          inputSchema: { q: "string" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "stale-deals-view",
          name: "At-Risk Deals",
          type: "table",
          source: { entity: "Deal", statePath: "hubspot.deals" },
          fields: ["dealname", "last_activity_date", "days_inactive"],
          actions: ["hubspot.deals.open"],
        },
      ],
      query_plans: [
        {
          integrationId: "hubspot",
          actionId: "hubspot.deals.open",
          query: { properties: ["dealname", "amount", "associations"] },
          fields: ["dealname"],
        },
        {
          integrationId: "google",
          actionId: "google.search.emails",
          query: { q: "from:client@domain.com after:2weeksAgo" },
          fields: ["snippet"],
        },
      ],
      answer_contract: {
        entity_type: "at_risk_deal",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Identify stale deals",
        sub_goals: ["List deals >10k", "Check last interaction", "Filter by 14 days"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Find stale deals",
        integrations: ["hubspot", "google"],
        objects: ["Deal", "Email"],
        successCriteria: ["List of stalled deals"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Deal"], minimumRecords: 1 },
    }),
  },
  {
    id: "rev-churn-risk",
    name: "Churn Risk Radar",
    description: "Detect high-value customers with declining usage (Intercom) and open support tickets (Zendesk).",
    category: "Revenue, Sales & CRM",
    integrations: ["intercom", "zendesk", "stripe"],
    trigger: "Time-based",
    output: "Alert",
    prompt: "Alert me of any enterprise customers who have logged >3 urgent tickets and have declining usage.",
    spec: buildSpec({
      id: "rev-churn-risk",
      name: "Churn Risk Radar",
      description: "Early warning system for churn.",
      purpose: "Save high-value accounts.",
      integrations: ["intercom", "zendesk", "stripe"],
      entities: [intercomConversationEntity, zendeskTicketEntity, stripeChargeEntity],
      actions: [
        {
          id: "intercom.users.usage",
          name: "Check usage stats",
          description: "Get user activity segments",
          type: "READ",
          integrationId: "intercom",
          capabilityId: "intercom_conversations_list", // Proxy capability
          inputSchema: { segment_id: "string" },
          outputSchema: { users: "array" },
          writesToState: false,
        },
        {
          id: "zendesk.tickets.urgent",
          name: "Get urgent tickets",
          description: "List recent high priority tickets",
          type: "READ",
          integrationId: "zendesk",
          capabilityId: "zendesk_tickets_list",
          inputSchema: { query: "string" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "churn-risk-view",
          name: "Churn Watchlist",
          type: "table",
          source: { entity: "Ticket", statePath: "zendesk.issues" },
          fields: ["customer", "ticket_count", "mrr_value"],
          actions: ["zendesk.tickets.urgent"],
        },
      ],
      query_plans: [
        {
          integrationId: "intercom",
          actionId: "intercom.users.usage",
          query: { segment_id: "declining_usage" },
          fields: ["email", "session_count"],
        },
        {
          integrationId: "zendesk",
          actionId: "zendesk.tickets.urgent",
          query: { query: "type:ticket priority:urgent status:open" },
          fields: ["subject"],
        },
      ],
      answer_contract: {
        entity_type: "risk_account",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Identify churn risk",
        sub_goals: ["Find urgent tickets", "Correlate with usage drops", "Check MRR"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Prevent churn",
        integrations: ["intercom", "zendesk", "stripe"],
        objects: ["Ticket", "Charge"],
        successCriteria: ["Risk list generated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Ticket"], minimumRecords: 1 },
    }),
  },
  {
    id: "rev-product-feedback",
    name: "Sales-to-Product Feedback Loop",
    description: "Aggregation of feature requests from HubSpot notes and Gong call summaries pushing to Linear.",
    category: "Revenue, Sales & CRM",
    integrations: ["hubspot", "linear"],
    trigger: "Prompt-based",
    output: "Document",
    prompt: "Aggregate all feature requests for 'Reporting' from recent sales calls and draft Linear issues.",
    spec: buildSpec({
      id: "rev-product-feedback",
      name: "Sales Feedback Loop",
      description: "Bridge sales and product.",
      purpose: "Build what sells.",
      integrations: ["hubspot", "linear"],
      entities: [hubspotDealEntity, linearIssueEntity],
      actions: [
        {
          id: "hubspot.notes.search",
          name: "Search call notes",
          description: "Find notes with keywords",
          type: "READ",
          integrationId: "hubspot",
          capabilityId: "hubspot_deals_list", // Proxy note search via deals/contacts association
          inputSchema: { query: "string" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "feedback-view",
          name: "Feature Requests",
          type: "table",
          source: { entity: "Deal", statePath: "hubspot.feedback" },
          fields: ["note_body", "associated_deal_value"],
          actions: ["hubspot.notes.search"],
        },
      ],
      query_plans: [
        {
          integrationId: "hubspot",
          actionId: "hubspot.notes.search",
          query: { query: "feature request reporting" },
          fields: ["body"],
        },
      ],
      answer_contract: {
        entity_type: "feature_request",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "TRANSFORMATION",
        primary_goal: "Aggregate feedback",
        sub_goals: ["Search notes", "Cluster by topic", "Format for Linear"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Process sales feedback",
        integrations: ["hubspot", "linear"],
        objects: ["Deal", "Issue"],
        successCriteria: ["Feedback document created"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Deal"], minimumRecords: 1 },
    }),
  },
  {
    id: "rev-high-value-prospect",
    name: "High-Value Prospect Monitor",
    description: "Identify companies visiting pricing pages (Google Analytics) that match Ideal Customer Profile (HubSpot).",
    category: "Revenue, Sales & CRM",
    integrations: ["google_analytics", "hubspot"],
    trigger: "Time-based",
    output: "Alert",
    prompt: "Notify sales when a prospect in our 'Target Accounts' list visits the pricing page.",
    spec: buildSpec({
      id: "rev-high-value-prospect",
      name: "High-Value Prospect Monitor",
      description: "De-anonymize high intent traffic.",
      purpose: "Alert sales to intent.",
      integrations: ["google_analytics", "hubspot"],
      entities: [googleAnalyticsReportEntity, hubspotDealEntity],
      actions: [
        {
          id: "ga.traffic.companies",
          name: "Get visiting companies",
          description: "Identify companies from network domain",
          type: "READ",
          integrationId: "google_analytics",
          capabilityId: "google_analytics_reports_run",
          inputSchema: { dimensions: "array" },
          outputSchema: { rows: "array" },
          writesToState: false,
        },
        {
          id: "hubspot.companies.target",
          name: "Check target status",
          description: "Verify if company is target account",
          type: "READ",
          integrationId: "hubspot",
          capabilityId: "hubspot_deals_list", // Proxy company search
          inputSchema: { domain: "string" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "prospect-view",
          name: "Hot Prospects",
          type: "table",
          source: { entity: "Report", statePath: "ga.visits" },
          fields: ["company_name", "page_visited", "deal_status"],
          actions: ["ga.traffic.companies"],
        },
      ],
      query_plans: [
        {
          integrationId: "google_analytics",
          actionId: "ga.traffic.companies",
          query: { dimensions: ["city", "pagePath"] }, // Approx for company matching
          fields: ["activeUsers"],
        },
        {
          integrationId: "hubspot",
          actionId: "hubspot.companies.target",
          query: { domain: "acme.com" },
          fields: ["target_account_status"],
        },
      ],
      answer_contract: {
        entity_type: "prospect_alert",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Identify hot leads",
        sub_goals: ["Extract domains from GA", "Match to HubSpot", "Filter by target"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Find high intent leads",
        integrations: ["google_analytics", "hubspot"],
        objects: ["Report", "Deal"],
        successCriteria: ["Intent list generated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Deal"], minimumRecords: 0 },
    }),
  },
  {
    id: "rev-sla-breach",
    name: "SLA Breach Predictor",
    description: "Predict which Zendesk tickets are at risk of breaching SLA based on volume and agent availability.",
    category: "Revenue, Sales & CRM",
    integrations: ["zendesk", "slack"],
    trigger: "Time-based",
    output: "Table",
    prompt: "Show me all tickets that will breach SLA in the next 4 hours given current ticket velocity.",
    spec: buildSpec({
      id: "rev-sla-breach",
      name: "SLA Breach Predictor",
      description: "Prevent SLA violations.",
      purpose: "Maintain trust.",
      integrations: ["zendesk", "slack"],
      entities: [zendeskTicketEntity, slackMessageEntity],
      actions: [
        {
          id: "zendesk.tickets.risk",
          name: "Get at-risk tickets",
          description: "List tickets nearing SLA",
          type: "READ",
          integrationId: "zendesk",
          capabilityId: "zendesk_tickets_list",
          inputSchema: { query: "string" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "sla-risk-view",
          name: "SLA Risks",
          type: "table",
          source: { entity: "Ticket", statePath: "zendesk.risks" },
          fields: ["subject", "time_to_breach", "assigned_to"],
          actions: ["zendesk.tickets.risk"],
        },
      ],
      query_plans: [
        {
          integrationId: "zendesk",
          actionId: "zendesk.tickets.risk",
          query: { query: "sla_next_breach<4hours status:open" },
          fields: ["subject", "sla"],
        },
      ],
      answer_contract: {
        entity_type: "sla_risk",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Predict SLA breaches",
        sub_goals: ["List nearing tickets", "Calculate remaining time"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Avoid SLA breach",
        integrations: ["zendesk", "slack"],
        objects: ["Ticket"],
        successCriteria: ["Breach list generated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Ticket"], minimumRecords: 1 },
    }),
  },
  {
    id: "rev-vip-onboarding",
    name: "VIP Customer Onboarding Tracker",
    description: "Sync HubSpot closed-won deals to Asana onboarding projects automatically.",
    category: "Revenue, Sales & CRM",
    integrations: ["hubspot", "asana"],
    trigger: "Event-based",
    output: "Summary",
    prompt: "When a deal >$50k closes in HubSpot, create a 'VIP Onboarding' project in Asana.",
    spec: buildSpec({
      id: "rev-vip-onboarding",
      name: "VIP Onboarding Sync",
      description: "Automate handover to success.",
      purpose: "Seamless customer experience.",
      integrations: ["hubspot", "asana"],
      entities: [hubspotDealEntity /* Asana Project Entity needed */],
      actions: [
        {
          id: "hubspot.deals.won",
          name: "Get recent wins",
          description: "Fetch new closed won deals",
          type: "READ",
          integrationId: "hubspot",
          capabilityId: "hubspot_deals_list",
          inputSchema: { properties: "array" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "handover-view",
          name: "Pending Handovers",
          type: "table",
          source: { entity: "Deal", statePath: "hubspot.wins" },
          fields: ["dealname", "amount", "onboarding_status"],
          actions: ["hubspot.deals.won"],
        },
      ],
      query_plans: [
        {
          integrationId: "hubspot",
          actionId: "hubspot.deals.won",
          query: { properties: ["dealname", "amount", "closedate"] },
          fields: ["dealname"],
        },
      ],
      answer_contract: {
        entity_type: "handover_task",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "TRANSFORMATION",
        primary_goal: "Initiate onboarding",
        sub_goals: ["Find qualifying deals", "Create project structure"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Start onboarding",
        integrations: ["hubspot", "asana"],
        objects: ["Deal"],
        successCriteria: ["Project created"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Deal"], minimumRecords: 0 },
    }),
  },
  {
    id: "rev-sales-leaderboard",
    name: "Sales Performance Leaderboard",
    description: "Weekly leaderboard of calls made (HubSpot) vs. deals advanced (HubSpot) posted to Slack.",
    category: "Revenue, Sales & CRM",
    integrations: ["hubspot", "slack"],
    trigger: "Time-based",
    output: "Document",
    prompt: "Generate the weekly sales leaderboard highlighting top movers and call volume leaders.",
    spec: buildSpec({
      id: "rev-sales-leaderboard",
      name: "Sales Leaderboard",
      description: "Gamify sales activity.",
      purpose: "Motivate sales team.",
      integrations: ["hubspot", "slack"],
      entities: [hubspotDealEntity],
      actions: [
        {
          id: "hubspot.activity.calls",
          name: "Count calls",
          description: "Count calls per rep",
          type: "READ",
          integrationId: "hubspot",
          capabilityId: "hubspot_deals_list", // Proxy activity search
          inputSchema: { filter: "string" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "leaderboard-view",
          name: "Leaderboard",
          type: "table",
          source: { entity: "Deal", statePath: "hubspot.stats" },
          fields: ["rep_name", "calls", "deals_moved"],
          actions: ["hubspot.activity.calls"],
        },
      ],
      query_plans: [
        {
          integrationId: "hubspot",
          actionId: "hubspot.activity.calls",
          query: { filter: "calls_last_week" },
          fields: ["owner", "count"],
        },
      ],
      answer_contract: {
        entity_type: "leaderboard_entry",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Generate leaderboard",
        sub_goals: ["Aggreate calls", "Aggregate deal movement", "Rank owners"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Motivate team",
        integrations: ["hubspot", "slack"],
        objects: ["Deal"],
        successCriteria: ["Leaderboard published"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Deal"], minimumRecords: 1 },
    }),
  },
  // =================================================================
  // CUSTOMER SUPPORT & SUCCESS
  // =================================================================
  {
    id: "cs-ticket-sentiment",
    name: "Ticket Sentiment Analyzer",
    description: "Analyze the sentiment of incoming Zendesk tickets to prioritize angry customers.",
    category: "Customer Support & Success",
    integrations: ["zendesk", "slack"],
    trigger: "Event-based",
    output: "Alert",
    prompt: "Monitor incoming Zendesk tickets. If sentiment is negative, alert the #support-managers channel.",
    spec: buildSpec({
      id: "cs-ticket-sentiment",
      name: "Ticket Sentiment Analyzer",
      description: "Prioritize negative sentiment.",
      purpose: "De-escalate angry customers.",
      integrations: ["zendesk", "slack"],
      entities: [zendeskTicketEntity, slackMessageEntity],
      actions: [
        {
          id: "zendesk.tickets.recent",
          name: "Get recent tickets",
          description: "Fetch new tickets",
          type: "READ",
          integrationId: "zendesk",
          capabilityId: "zendesk_tickets_list",
          inputSchema: { query: "string" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "sentiment-view",
          name: "Negative Sentiment",
          type: "table",
          source: { entity: "Ticket", statePath: "zendesk.negative" },
          fields: ["subject", "sentiment_score", "customer"],
          actions: ["zendesk.tickets.recent"],
        },
      ],
      query_plans: [
        {
          integrationId: "zendesk",
          actionId: "zendesk.tickets.recent",
          query: { query: "status:new created>1hourAgo" },
          fields: ["description"],
        },
      ],
      answer_contract: {
        entity_type: "sentiment_alert",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Analyze Sentiment",
        sub_goals: ["Fetch ticket text", "Run sentiment analysis", "Filter < 0.3"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Prioritize angry customers",
        integrations: ["zendesk", "slack"],
        objects: ["Ticket"],
        successCriteria: ["Alert sent"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Ticket"], minimumRecords: 1 },
    }),
  },
  {
    id: "cs-auto-responder",
    name: "Auto-Responder Drafts",
    description: "Draft responses for new Zendesk tickets based on similar solved tickets and documentation.",
    category: "Customer Support & Success",
    integrations: ["zendesk", "notion"],
    trigger: "Event-based",
    output: "Document",
    prompt: "For every new ticket, draft a response using our Notion knowledge base and past solved tickets.",
    spec: buildSpec({
      id: "cs-auto-responder",
      name: "Auto-Responder",
      description: "AI-drafted replies.",
      purpose: "Reduce response time.",
      integrations: ["zendesk", "notion"],
      entities: [zendeskTicketEntity, notionPageEntity],
      actions: [
        {
          id: "zendesk.tickets.new",
          name: "Get new tickets",
          description: "Fetch unassigned tickets",
          type: "READ",
          integrationId: "zendesk",
          capabilityId: "zendesk_tickets_list",
          inputSchema: { query: "string" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
        {
          id: "notion.search.kb",
          name: "Search knowledge base",
          description: "Find relevant articles",
          type: "READ",
          integrationId: "notion",
          capabilityId: "notion_pages_search",
          inputSchema: { query: "string" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "drafts-view",
          name: "Response Drafts",
          type: "detail",
          source: { entity: "Ticket", statePath: "zendesk.drafts" },
          fields: ["subject", "suggested_reply", "confidence"],
          actions: ["zendesk.tickets.new"],
        },
      ],
      query_plans: [
        {
          integrationId: "zendesk",
          actionId: "zendesk.tickets.new",
          query: { query: "status:new" },
          fields: ["subject", "description"],
        },
        {
          integrationId: "notion",
          actionId: "notion.search.kb",
          query: { query: "troubleshooting" },
          fields: ["title", "content"],
        },
      ],
      answer_contract: {
        entity_type: "draft_response",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "TRANSFORMATION",
        primary_goal: "Draft responses",
        sub_goals: ["Retrieve context", "Generate draft", "Link sources"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Draft replies",
        integrations: ["zendesk", "notion"],
        objects: ["Ticket", "Page"],
        successCriteria: ["Drafts created"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Ticket"], minimumRecords: 1 },
    }),
  },
  {
    id: "cs-volume-anomaly",
    name: "Support Volume Anomaly Detection",
    description: "Detect unusual spikes in support volume on specific topics via Intercom.",
    category: "Customer Support & Success",
    integrations: ["intercom", "slack"],
    trigger: "Time-based",
    output: "Alert",
    prompt: "Scan usage of topic tags in Intercom. Alert me if any topic has >200% growth period-over-period.",
    spec: buildSpec({
      id: "cs-volume-anomaly",
      name: "Volume Anomaly Detector",
      description: "Spot outbreaks early.",
      purpose: "Resource allocation.",
      integrations: ["intercom", "slack"],
      entities: [intercomConversationEntity],
      actions: [
        {
          id: "intercom.tags.counts",
          name: "Count tag usage",
          description: "Get volume per tag",
          type: "READ",
          integrationId: "intercom",
          capabilityId: "intercom_conversations_list", // Proxy via search
          inputSchema: { query: "string" },
          outputSchema: { counts: "object" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "anomaly-view",
          name: "Trending Topics",
          type: "table",
          source: { entity: "Conversation", statePath: "intercom.trends" },
          fields: ["tag", "volume", "growth_pct"],
          actions: ["intercom.tags.counts"],
        },
      ],
      query_plans: [
        {
          integrationId: "intercom",
          actionId: "intercom.tags.counts",
          query: { query: "created_at>24h_ago" },
          fields: ["tags"],
        },
      ],
      answer_contract: {
        entity_type: "anomaly_alert",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Detect anomalies",
        sub_goals: ["Bucket by tag", "Compare to baseline", "Identify outliers"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Detect spikes",
        integrations: ["intercom", "slack"],
        objects: ["Conversation"],
        successCriteria: ["Anomaly detected"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Conversation"], minimumRecords: 10 },
    }),
  },
  {
    id: "cs-csm-prep",
    name: "CSM Quarterly Prep",
    description: "Prepare a QBR deck by aggregating HubSpot usage, Zendesk tickets, and Linear bugs for a customer.",
    category: "Customer Support & Success",
    integrations: ["hubspot", "zendesk", "linear"],
    trigger: "Prompt-based",
    output: "Document",
    prompt: "Prepare a QBR summary for 'Acme Corp' including open bugs, support ticket themes, and contract status.",
    spec: buildSpec({
      id: "cs-csm-prep",
      name: "CSM QBR Prep",
      description: "Automate account research.",
      purpose: "Better customer meetings.",
      integrations: ["hubspot", "zendesk", "linear"],
      entities: [hubspotDealEntity, zendeskTicketEntity, linearIssueEntity],
      actions: [
        {
          id: "hubspot.company.data",
          name: "Get company details",
          description: "Fetch contract info",
          type: "READ",
          integrationId: "hubspot",
          capabilityId: "hubspot_deals_list", // Proxy company
          inputSchema: { domain: "string" },
          outputSchema: { company: "object" },
          writesToState: false,
        },
        {
          id: "zendesk.tickets.customer",
          name: "Get customer tickets",
          description: "Fetch recent tickets",
          type: "READ",
          integrationId: "zendesk",
          capabilityId: "zendesk_tickets_list",
          inputSchema: { query: "string" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
        {
          id: "linear.issues.customer",
          name: "Get customer bugs",
          description: "Fetch reported bugs",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list",
          inputSchema: { filter: "string" },
          outputSchema: { nodes: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "qbr-view",
          name: "QBR Summary",
          type: "detail",
          source: { entity: "Deal", statePath: "hubspot.qbr" },
          fields: ["health_score", "open_bugs", "ticket_volume"],
          actions: ["hubspot.company.data"],
        },
      ],
      query_plans: [
        {
          integrationId: "hubspot",
          actionId: "hubspot.company.data",
          query: { domain: "acme.com" },
          fields: ["name", "renewal_date"],
        },
        {
          integrationId: "zendesk",
          actionId: "zendesk.tickets.customer",
          query: { query: "organization:Acme" },
          fields: ["subject"],
        },
        {
          integrationId: "linear",
          actionId: "linear.issues.customer",
          query: { filter: "label:Acme" },
          fields: ["title", "priority"],
        },
      ],
      answer_contract: {
        entity_type: "qbr_summary",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "object",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Prepare QBR",
        sub_goals: ["Summarize health", "List blocker bugs", "Review support history"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Prepare QBR",
        integrations: ["hubspot", "zendesk", "linear"],
        objects: ["Deal", "Ticket", "Issue"],
        successCriteria: ["QBR document generated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Deal"], minimumRecords: 1 },
    }),
  },
  {
    id: "cs-onboarding-bottleneck",
    name: "User Onboarding Bottleneck",
    description: "Identify where users drop off during onboarding by correlating Intercom tours with Google Analytics events.",
    category: "Customer Support & Success",
    integrations: ["intercom", "google_analytics"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Where are users getting stuck in the 'New User' tour? Compare Intercom step completion with GA page exits.",
    spec: buildSpec({
      id: "cs-onboarding-bottleneck",
      name: "Onboarding Bottleneck",
      description: "Improve activation rate.",
      purpose: "Smooth onboarding.",
      integrations: ["intercom", "google_analytics"],
      entities: [intercomConversationEntity, googleAnalyticsReportEntity],
      actions: [
        {
          id: "intercom.tour.stats",
          name: "Get tour stats",
          description: "Fetch tour step completion",
          type: "READ",
          integrationId: "intercom",
          capabilityId: "intercom_conversations_list", // Proxy tour stats
          inputSchema: { tour_id: "string" },
          outputSchema: { steps: "array" },
          writesToState: false,
        },
        {
          id: "ga.events.exits",
          name: "Get page exits",
          description: "Fetch exit rate by page",
          type: "READ",
          integrationId: "google_analytics",
          capabilityId: "google_analytics_reports_run",
          inputSchema: { dimensions: "array" },
          outputSchema: { rows: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "dropoff-view",
          name: "Drop-off Points",
          type: "table",
          source: { entity: "Report", statePath: "ga.dropoffs" },
          fields: ["step", "completion_rate", "exit_rate"],
          actions: ["intercom.tour.stats"],
        },
      ],
      query_plans: [
        {
          integrationId: "intercom",
          actionId: "intercom.tour.stats",
          query: { tour_id: "new_user_onboarding" },
          fields: ["step_name", "count"],
        },
        {
          integrationId: "google_analytics",
          actionId: "ga.events.exits",
          query: { dimensions: ["pagePath"], metrics: ["exitRate"] },
          fields: ["pagePath", "exitRate"],
        },
      ],
      answer_contract: {
        entity_type: "bottleneck",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Identify bottlenecks",
        sub_goals: ["Get tour funnels", "Get page exits", "Find correlation"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Fix onboarding",
        integrations: ["intercom", "google_analytics"],
        objects: ["Report"],
        successCriteria: ["Bottleneck identified"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Report"], minimumRecords: 1 },
    }),
  },
  {
    id: "cs-feature-triage",
    name: "Feature Request Triage",
    description: "Auto-tag Intercom conversations as 'Feature Request' and create Linear issues if >5 users ask.",
    category: "Customer Support & Success",
    integrations: ["intercom", "linear"],
    trigger: "Event-based",
    output: "Summary",
    prompt: "Scan recent Intercom chats for 'feature request'. If valid, create a Linear issue.",
    spec: buildSpec({
      id: "cs-feature-triage",
      name: "Feature Triage",
      description: "Automate feedback filing.",
      purpose: "Empower product team.",
      integrations: ["intercom", "linear"],
      entities: [intercomConversationEntity, linearIssueEntity],
      actions: [
        {
          id: "intercom.chats.search",
          name: "Search chats",
          description: "Find feedback keywords",
          type: "READ",
          integrationId: "intercom",
          capabilityId: "intercom_conversations_list",
          inputSchema: { query: "string" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
        {
          id: "linear.issue.create",
          name: "Create issue",
          description: "Draft new issue",
          type: "WRITE",
          integrationId: "linear",
          capabilityId: "linear_issues_list", // Proxy create
          inputSchema: { title: "string" },
          outputSchema: { issue: "object" },
          writesToState: true,
        },
      ],
      views: [
        {
          id: "triage-view",
          name: "Triage Queue",
          type: "table",
          source: { entity: "Conversation", statePath: "intercom.feedback" },
          fields: ["customer", "request", "linear_link"],
          actions: ["intercom.chats.search"],
        },
      ],
      query_plans: [
        {
          integrationId: "intercom",
          actionId: "intercom.chats.search",
          query: { query: "feature request" },
          fields: ["body"],
        },
      ],
      answer_contract: {
        entity_type: "triage_action",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "TRANSFORMATION",
        primary_goal: "Triage feedback",
        sub_goals: ["Identify requests", "Check duplicates", "File issue"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Triage features",
        integrations: ["intercom", "linear"],
        objects: ["Conversation", "Issue"],
        successCriteria: ["Issue created"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Conversation"], minimumRecords: 1 },
    }),
  },
  {
    id: "cs-vip-escalation",
    name: "VIP Escalation Protocol",
    description: "Monitor Zendesk for VIP tickets and create a dedicated Slack channel for swarming.",
    category: "Customer Support & Success",
    integrations: ["zendesk", "slack"],
    trigger: "Event-based",
    output: "Alert",
    prompt: "If a VIP ticket comes in (tag: vip), create a Slack channel #incident-[ticket-id] and invite on-call.",
    spec: buildSpec({
      id: "cs-vip-escalation",
      name: "VIP Escalation",
      description: "White glove service.",
      purpose: "Retain VIPs.",
      integrations: ["zendesk", "slack"],
      entities: [zendeskTicketEntity, slackMessageEntity],
      actions: [
        {
          id: "zendesk.tickets.vip",
          name: "Check VIP tickets",
          description: "Listen for new VIP tickets",
          type: "READ",
          integrationId: "zendesk",
          capabilityId: "zendesk_tickets_list",
          inputSchema: { query: "string" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
        {
          id: "slack.channel.create",
          name: "Create swarm channel",
          description: "Setup incident channel",
          type: "WRITE",
          integrationId: "slack",
          capabilityId: "slack_messages_list", // Proxy create channel
          inputSchema: { name: "string" },
          outputSchema: { channel: "object" },
          writesToState: true,
        },
      ],
      views: [
        {
          id: "escalation-view",
          name: "Active Escalations",
          type: "table",
          source: { entity: "Ticket", statePath: "zendesk.vips" },
          fields: ["ticket", "slack_channel", "status"],
          actions: ["zendesk.tickets.vip"],
        },
      ],
      query_plans: [
        {
          integrationId: "zendesk",
          actionId: "zendesk.tickets.vip",
          query: { query: "tags:vip status:new" },
          fields: ["subject"],
        },
      ],
      answer_contract: {
        entity_type: "escalation_event",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "TRANSFORMATION",
        primary_goal: "Escalate VIPs",
        sub_goals: ["Detect VIP ticket", "Create Slack channel", "Notify team"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Escalate VIP issues",
        integrations: ["zendesk", "slack"],
        objects: ["Ticket"],
        successCriteria: ["Swarm channel created"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Ticket"], minimumRecords: 0 },
    }),
  },
  {
    id: "cs-kb-gap",
    name: "Knowledge Base Gap Analysis",
    description: "Analyze failed Intercom searches and suggested creating new Notion articles.",
    category: "Customer Support & Success",
    integrations: ["intercom", "notion"],
    trigger: "Time-based",
    output: "Table",
    prompt: "Identify the top 5 search terms in Intercom help center that returned 0 results last week.",
    spec: buildSpec({
      id: "cs-kb-gap",
      name: "KB Gap Analysis",
      description: "Improve help center.",
      purpose: "Deflect tickets.",
      integrations: ["intercom", "notion"],
      entities: [intercomConversationEntity, notionPageEntity],
      actions: [
        {
          id: "intercom.searches.failed",
          name: "Get failed searches",
          description: "Fetch searches with 0 results",
          type: "READ",
          integrationId: "intercom",
          capabilityId: "intercom_conversations_list", // Proxy help center analytics
          inputSchema: { timeframe: "string" },
          outputSchema: { terms: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "gap-view",
          name: "Content Gaps",
          type: "table",
          source: { entity: "Report", statePath: "intercom.gaps" },
          fields: ["term", "search_count", "suggested_title"],
          actions: ["intercom.searches.failed"],
        },
      ],
      query_plans: [
        {
          integrationId: "intercom",
          actionId: "intercom.searches.failed",
          query: { metrics: ["failed_search_count"] },
          fields: ["term"],
        },
      ],
      answer_contract: {
        entity_type: "content_gap",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Identify content gaps",
        sub_goals: ["Count failed searches", "Cluster terms", "Propose articles"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Improve knowledge base",
        integrations: ["intercom", "notion"],
        objects: ["Page"],
        successCriteria: ["Gaps identified"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Page"], minimumRecords: 0 },
    }),
  },
  // =================================================================
  // OPERATIONS & FINANCE
  // =================================================================
  {
    id: "ops-vendor-spend",
    name: "Vendor Spend Audit",
    description: "Cross-reference QuickBooks expenses with Gmail invoices to identify missing receipts.",
    category: "Operations & Finance",
    integrations: ["quickbooks", "google"],
    trigger: "Time-based",
    output: "Table",
    prompt: "Match all QuickBooks expenses >$100 last month with invoices found in Gmail. List missing receipts.",
    spec: buildSpec({
      id: "ops-vendor-spend",
      name: "Vendor Spend Audit",
      description: "Automate expense reconciliation.",
      purpose: "Audit compliance.",
      integrations: ["quickbooks", "google"],
      entities: [emailEntity /* quickbooksExpenseEntity needed? Using transaction proxy */],
      actions: [
        {
          id: "quickbooks.expenses.list",
          name: "Get expenses",
          description: "Fetch recent expenses",
          type: "READ",
          integrationId: "quickbooks",
          capabilityId: "quickbooks_reports_run", // Proxy via report or transaction list
          inputSchema: { min_amount: "number" },
          outputSchema: { expenses: "array" },
          writesToState: false,
        },
        {
          id: "google.search.invoices",
          name: "Search invoices",
          description: "Find invoice emails",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list",
          inputSchema: { q: "string" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "audit-view",
          name: "Reciept Audit",
          type: "table",
          source: { entity: "Expense", statePath: "quickbooks.audit" },
          fields: ["vendor", "amount", "receipt_status"],
          actions: ["quickbooks.expenses.list"],
        },
      ],
      query_plans: [
        {
          integrationId: "quickbooks",
          actionId: "quickbooks.expenses.list",
          query: { min_amount: 100 },
          fields: ["vendor", "amount"],
        },
        {
          integrationId: "google",
          actionId: "google.search.invoices",
          query: { q: "subject:invoice has:attachment" },
          fields: ["subject"],
        },
      ],
      answer_contract: {
        entity_type: "audit_entry",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Audit expenses",
        sub_goals: ["List expenses", "Find matching emails", "Flag missing"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Audit spend",
        integrations: ["quickbooks", "google"],
        objects: ["Email"],
        successCriteria: ["Audit report generated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Email"], minimumRecords: 1 },
    }),
  },
  {
    id: "ops-contract-removal",
    name: "Contract Renewal Alert",
    description: "Monitor HubSpot deal renewal dates and alert Slack 60 days in advance.",
    category: "Operations & Finance",
    integrations: ["hubspot", "slack"],
    trigger: "Time-based",
    output: "Alert",
    prompt: "Scan all active HubSpot contracts. Alert #finance if any contract >$20k is renewing in 60 days.",
    spec: buildSpec({
      id: "ops-contract-removal",
      name: "Renewal Alert",
      description: "Avoid surprise renewals.",
      purpose: "Financial forecasting.",
      integrations: ["hubspot", "slack"],
      entities: [hubspotDealEntity, slackMessageEntity],
      actions: [
        {
          id: "hubspot.deals.renewals",
          name: "Get upcoming renewals",
          description: "Fetch deals expiring soon",
          type: "READ",
          integrationId: "hubspot",
          capabilityId: "hubspot_deals_list",
          inputSchema: { properties: "array" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "renewal-view",
          name: "Upcoming Renewals",
          type: "table",
          source: { entity: "Deal", statePath: "hubspot.renewals" },
          fields: ["dealname", "amount", "renewal_date"],
          actions: ["hubspot.deals.renewals"],
        },
      ],
      query_plans: [
        {
          integrationId: "hubspot",
          actionId: "hubspot.deals.renewals",
          query: { properties: ["dealname", "amount", "renewal_date"] },
          fields: ["dealname"],
        },
      ],
      answer_contract: {
        entity_type: "renewal_alert",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Track renewals",
        sub_goals: ["Filter by date", "Filter by amount", "Notify channel"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Track renewals",
        integrations: ["hubspot", "slack"],
        objects: ["Deal"],
        successCriteria: ["Alert sent"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Deal"], minimumRecords: 1 },
    }),
  },
  {
    id: "ops-interview-load",
    name: "Interview Load Balancer",
    description: "Analyze Zoom interview volume per interviewer and suggest rebalancing via Slack.",
    category: "Operations & Finance",
    integrations: ["zoom", "slack"],
    trigger: "Time-based",
    output: "Table",
    prompt: "Analyze Zoom meeting logs for 'interview'. Identify interviewers with >5 hours/week and suggest alternates.",
    spec: buildSpec({
      id: "ops-interview-load",
      name: "Interview Load Balancer",
      description: "Prevent interviewer burnout.",
      purpose: "Fair hiring load.",
      integrations: ["zoom", "slack"],
      entities: [slackMessageEntity /* Zoom Meeting Entity needed */],
      actions: [
        {
          id: "zoom.meetings.list",
          name: "Get meeting logs",
          description: "Fetch recent meetings",
          type: "READ",
          integrationId: "zoom",
          capabilityId: "zoom_meetings_list", // Proxy capability
          inputSchema: { type: "string" },
          outputSchema: { meetings: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "load-view",
          name: "Interviewer Load",
          type: "table",
          source: { entity: "Meeting", statePath: "zoom.interviews" },
          fields: ["host", "hours_spent", "status"],
          actions: ["zoom.meetings.list"],
        },
      ],
      query_plans: [
        {
          integrationId: "zoom",
          actionId: "zoom.meetings.list",
          query: { type: "scheduled" },
          fields: ["topic", "duration", "host_email"],
        },
      ],
      answer_contract: {
        entity_type: "load_report",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Balance load",
        sub_goals: ["Filter for interview", "Sum duration by host", "Flag overload"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Balance interviews",
        integrations: ["zoom", "slack"],
        objects: ["Message"],
        successCriteria: ["Load report generated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Message"], minimumRecords: 0 },
    }),
  },
  {
    id: "ops-payment-failure",
    name: "Payment Failure Recovery",
    description: "Detect failed Stripe payments >$100 and create high-priority Linear issues for Ops.",
    category: "Operations & Finance",
    integrations: ["stripe", "linear"],
    trigger: "Event-based",
    output: "Alert",
    prompt: "Monitor Stripe for failed charges >$100. Create a Linear issue 'Collections: [Customer]' for each.",
    spec: buildSpec({
      id: "ops-payment-failure",
      name: "Payment Recovery",
      description: "Recover lost revenue.",
      purpose: "Maximize collections.",
      integrations: ["stripe", "linear"],
      entities: [stripeChargeEntity, linearIssueEntity],
      actions: [
        {
          id: "stripe.charges.failed",
          name: "Get failed charges",
          description: "Fetch declines",
          type: "READ",
          integrationId: "stripe",
          capabilityId: "stripe_charges_list",
          inputSchema: { status: "string" },
          outputSchema: { data: "array" },
          writesToState: false,
        },
        {
          id: "linear.issue.create_collection",
          name: "Create collection task",
          description: "Assign to finance",
          type: "WRITE",
          integrationId: "linear",
          capabilityId: "linear_issues_list", // Proxy create
          inputSchema: { title: "string" },
          outputSchema: { issue: "object" },
          writesToState: true,
        },
      ],
      views: [
        {
          id: "collections-view",
          name: "Failed Payments",
          type: "table",
          source: { entity: "Charge", statePath: "stripe.failed" },
          fields: ["amount", "customer_email", "issue_link"],
          actions: ["stripe.charges.failed"],
        },
      ],
      query_plans: [
        {
          integrationId: "stripe",
          actionId: "stripe.charges.failed",
          query: { status: "failed" },
          fields: ["amount", "billing_details"],
        },
      ],
      answer_contract: {
        entity_type: "collection_task",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "TRANSFORMATION",
        primary_goal: "Initiate collections",
        sub_goals: ["Find failures", "Create issue"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Recover payments",
        integrations: ["stripe", "linear"],
        objects: ["Charge", "Issue"],
        successCriteria: ["Issues created"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Charge"], minimumRecords: 1 },
    }),
  },
  {
    id: "ops-onboarding-orchestrator",
    name: "Employee Onboarding Orchestrator",
    description: "Provision Google Workspace, invite to Slack, and create onboarding tasks in Linear for new hires.",
    category: "Operations & Finance",
    integrations: ["google", "slack", "linear"],
    trigger: "Prompt-based",
    output: "Summary",
    prompt: "Onboard new hire 'John Doe' (john@acme.com) to Engineering. Invite to Slack/Google and create tasks.",
    spec: buildSpec({
      id: "ops-onboarding-orchestrator",
      name: "Onboarding Orchestrator",
      description: "Automate IT setup.",
      purpose: "Smooth day one.",
      integrations: ["google", "slack", "linear"],
      entities: [emailEntity, slackMessageEntity, linearIssueEntity],
      actions: [
        {
          id: "google.admin.create",
          name: "Create user",
          description: "Provision account",
          type: "WRITE",
          integrationId: "google",
          capabilityId: "google_gmail_list", // Proxy admin
          inputSchema: { email: "string" },
          outputSchema: { user: "object" },
          writesToState: true,
        },
        // Additional actions for Slack invite and Linear tasks
      ],
      views: [
        {
          id: "onboarding-view",
          name: "Onboarding Status",
          type: "detail",
          source: { entity: "Issue", statePath: "onboarding.status" },
          fields: ["google_status", "slack_invite", "tasks_created"],
          actions: ["google.admin.create"],
        },
      ],
      query_plans: [
        // Placeholder queries
        {
          integrationId: "linear",
          actionId: "linear.issue.create_collection", // Reusing for schema validity
          query: {},
          fields: ["id"]
        }
      ],
      answer_contract: {
        entity_type: "onboarding_result",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "object",
      },
      goal_plan: {
        kind: "TRANSFORMATION",
        primary_goal: "Onboard user",
        sub_goals: ["Provision access", "Assign tasks"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Onboard employee",
        integrations: ["google", "slack", "linear"],
        objects: ["Email", "Issue"],
        successCriteria: ["Accounts created"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: [], minimumRecords: 0 },
    }),
  },
  {
    id: "ops-board-deck",
    name: "Board Deck Data Aggregator",
    description: "Pull ARR (Stripe), Pipeline (HubSpot) and Burn (QuickBooks) into a Google Sheet.",
    category: "Operations & Finance",
    integrations: ["stripe", "hubspot", "quickbooks", "google"],
    trigger: "Time-based",
    output: "Document",
    prompt: "Update the 'Board Metrics' Google Sheet with this month's ARR, Pipeline, and Expenses.",
    spec: buildSpec({
      id: "ops-board-deck",
      name: "Board Data Sync",
      description: "Automate reporting.",
      purpose: "Investor relations.",
      integrations: ["stripe", "hubspot", "quickbooks", "google"],
      entities: [stripeChargeEntity, hubspotDealEntity],
      actions: [
        {
          id: "google.sheets.update",
          name: "Update sheet",
          description: "Write metrics",
          type: "WRITE",
          integrationId: "google",
          capabilityId: "google_docs_create", // Proxy sheets
          inputSchema: { range: "string" },
          outputSchema: { updated: "boolean" },
          writesToState: true,
        },
      ],
      views: [
        {
          id: "metrics-view",
          name: "Board Metrics",
          type: "table",
          source: { entity: "Deal", statePath: "metrics.aggregated" },
          fields: ["metric", "value", "source"],
          actions: ["google.sheets.update"],
        },
      ],
      query_plans: [
        {
          integrationId: "stripe",
          actionId: "stripe.charges.failed", // Reusing
          query: { status: "succeeded" },
          fields: ["amount"]
        }
      ],
      answer_contract: {
        entity_type: "board_metrics",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "TRANSFORMATION",
        primary_goal: "Update metrics",
        sub_goals: ["Fetch all data", "Format for sheet", "Write to sheet"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Update board deck",
        integrations: ["stripe", "hubspot", "google"],
        objects: ["Deal", "Charge"],
        successCriteria: ["Sheet updated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Deal"], minimumRecords: 1 },
    }),
  },
  {
    id: "ops-compliance-audit",
    name: "Compliance Audit Trail",
    description: "Generate a log of all access changes in GitHub and Linear for SOC2 compliance.",
    category: "Operations & Finance",
    integrations: ["github", "linear"],
    trigger: "Time-based",
    output: "Document",
    prompt: "Generate a compliance report showing all user additions/removals in GitHub and Linear last quarter.",
    spec: buildSpec({
      id: "ops-compliance-audit",
      name: "Access Audit",
      description: "SOC2 evidence.",
      purpose: "Security compliance.",
      integrations: ["github", "linear"],
      entities: [linearIssueEntity /* GitHub User Entity? */],
      actions: [
        {
          id: "github.org.members",
          name: "Get member changes",
          description: "Audit log search",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_pull_requests_list", // Proxy audit log
          inputSchema: { action: "string" },
          outputSchema: { events: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "compliance-view",
          name: "Access Log",
          type: "table",
          source: { entity: "Issue", statePath: "audit.logs" },
          fields: ["user", "action", "platform", "date"],
          actions: ["github.org.members"],
        },
      ],
      query_plans: [
        {
          integrationId: "github",
          actionId: "github.org.members",
          query: { action: "team.add_member" },
          fields: ["actor", "user"],
        },
      ],
      answer_contract: {
        entity_type: "audit_log",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Generate audit trail",
        sub_goals: ["Query GitHub logs", "Query Linear logs", "Merge timelines"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Audit access",
        integrations: ["github", "linear"],
        objects: ["Issue"],
        successCriteria: ["Audit report generated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 0 },
    }),
  },
  {
    id: "ops-incident-response",
    name: "Incident Response Coordinator",
    description: "Orchestrate incident response: Create Jira ticket, Slack channel, and Zoom bridge.",
    category: "Operations & Finance",
    integrations: ["jira", "slack", "zoom"],
    trigger: "Prompt-based",
    output: "Summary",
    prompt: "Declare an incident 'Database Latency'. Create Jira ticket, #incident-db-latency channel, and Zoom link.",
    spec: buildSpec({
      id: "ops-incident-response",
      name: "Incident Coordinator",
      description: "Fast incident spin-up.",
      purpose: "Reduce MTTR.",
      integrations: ["jira", "slack", "zoom"],
      entities: [slackMessageEntity /* Jira Ticket Entity? Using generic task */],
      actions: [
        {
          id: "jira.issue.create",
          name: "Create ticket",
          description: "File incident ticket",
          type: "WRITE",
          integrationId: "jira",
          capabilityId: "jira_issues_create",
          inputSchema: { summary: "string" },
          outputSchema: { key: "string" },
          writesToState: true,
        },
        {
          id: "zoom.meeting.create",
          name: "Create bridge",
          description: "Start war room",
          type: "WRITE",
          integrationId: "zoom",
          capabilityId: "zoom_meetings_create",
          inputSchema: { topic: "string" },
          outputSchema: { join_url: "string" },
          writesToState: true,
        },
      ],
      views: [
        {
          id: "incident-view",
          name: "Incident Active",
          type: "detail",
          source: { entity: "Message", statePath: "incident.resources" },
          fields: ["jira_link", "slack_channel", "zoom_bridge"],
          actions: ["jira.issue.create"],
        },
      ],
      query_plans: [], // Write-only
      answer_contract: {
        entity_type: "incident_resources",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "object",
      },
      goal_plan: {
        kind: "TRANSFORMATION",
        primary_goal: "Declare incident",
        sub_goals: ["Create ticket", "Create channel", "Create bridge"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Declare incident",
        integrations: ["jira", "slack", "zoom"],
        objects: ["Message"],
        successCriteria: ["Resources created"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: [], minimumRecords: 0 },
    }),
  },
  // =================================================================
  // EXECUTIVE & LEADERSHIP
  // =================================================================
  {
    id: "exec-competitor-feed",
    name: "Competitor Intelligence Feed",
    description: "Monitor competitor news via Google Search and post summaries to a private Slack channel.",
    category: "Executive & Leadership",
    integrations: ["google", "slack"],
    trigger: "Time-based",
    output: "Summary",
    prompt: "Search for 'competitor funding news' and 'competitor product launch'. Summarize and post to #exec-strategy.",
    spec: buildSpec({
      id: "exec-competitor-feed",
      name: "Competitor Intel",
      description: "Stay ahead of market.",
      purpose: "Strategic awareness.",
      integrations: ["google", "slack"],
      entities: [slackMessageEntity /* Google Search Result Entity? Proxy via simple list */],
      actions: [
        {
          id: "google.search.news",
          name: "Search news",
          description: "Find recent news",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list", // Proxy or use a generic search capability if avail, else Gmail alerts
          inputSchema: { q: "string" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "feed-view",
          name: "Market News",
          type: "table",
          source: { entity: "Message", statePath: "market.news" },
          fields: ["headline", "source", "summary"],
          actions: ["google.search.news"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.search.news",
          query: { q: "competitor name news" },
          fields: ["title", "snippet"],
        },
      ],
      answer_contract: {
        entity_type: "news_item",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Monitor competitors",
        sub_goals: ["Search news", "Filter noise", "Summarize"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Monitor market",
        integrations: ["google", "slack"],
        objects: ["Message"],
        successCriteria: ["News digest posted"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: [], minimumRecords: 0 },
    }),
  },
  {
    id: "exec-cash-runway",
    name: "Cash Runway Monitor",
    description: "Calculate runway based on QuickBooks bank balance and average monthly burn.",
    category: "Executive & Leadership",
    integrations: ["quickbooks", "slack"],
    trigger: "Time-based",
    output: "Alert",
    prompt: "Calculate current cash runway. If <6 months, alert the #exec-finance channel immediately.",
    spec: buildSpec({
      id: "exec-cash-runway",
      name: "Runway Monitor",
      description: "Survival metric.",
      purpose: "Financial safety.",
      integrations: ["quickbooks", "slack"],
      entities: [slackMessageEntity],
      actions: [
        {
          id: "quickbooks.cash.balance",
          name: "Get cash balance",
          description: "Fetch bank accounts",
          type: "READ",
          integrationId: "quickbooks",
          capabilityId: "quickbooks_reports_run",
          inputSchema: { account_type: "string" },
          outputSchema: { balance: "number" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "runway-view",
          name: "Cash Position",
          type: "detail",
          source: { entity: "Message", statePath: "finance.runway" },
          fields: ["cash_balance", "monthly_burn", "runway_months"],
          actions: ["quickbooks.cash.balance"],
        },
      ],
      query_plans: [
        {
          integrationId: "quickbooks",
          actionId: "quickbooks.cash.balance",
          query: { account_type: "Bank" },
          fields: ["CurrentBalance"],
        },
      ],
      answer_contract: {
        entity_type: "runway_report",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "object",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Calculate runway",
        sub_goals: ["Get cash", "Get average expense", "Divide"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Check runway",
        integrations: ["quickbooks", "slack"],
        objects: ["Message"],
        successCriteria: ["Runway calculated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: [], minimumRecords: 0 },
    }),
  },
  {
    id: "exec-key-hires",
    name: "Key Hire Pipeline",
    description: "Track progress on 'Director' level roles in ATS (Linear proxy) and report to Board channel.",
    category: "Executive & Leadership",
    integrations: ["linear", "slack"],
    trigger: "Time-based",
    output: "Table",
    prompt: "List all open roles with 'Director' in title. Show days open and current stage.",
    spec: buildSpec({
      id: "exec-key-hires",
      name: "Executive Hiring",
      description: "Track leadership hires.",
      purpose: "Team growth.",
      integrations: ["linear", "slack"],
      entities: [linearIssueEntity],
      actions: [
        {
          id: "linear.roles.search",
          name: "Search roles",
          description: "Find open reqs",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list", // Proxy ATS
          inputSchema: { filter: "string" },
          outputSchema: { roles: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "hiring-view",
          name: "Key Hires",
          type: "table",
          source: { entity: "Issue", statePath: "hiring.exec" },
          fields: ["role", "days_open", "candidates"],
          actions: ["linear.roles.search"],
        },
      ],
      query_plans: [
        {
          integrationId: "linear",
          actionId: "linear.roles.search",
          query: { filter: "title:Director status:open" },
          fields: ["title", "createdAt"],
        },
      ],
      answer_contract: {
        entity_type: "hiring_status",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Track key hires",
        sub_goals: ["Filter roles", "Calculate time to fill"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Track hiring",
        integrations: ["linear", "slack"],
        objects: ["Issue"],
        successCriteria: ["Report generated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 0 },
    }),
  },
  // =================================================================
  // INTERNAL PRODUCTIVITY
  // =================================================================
  {
    id: "prod-meeting-summary",
    name: "Meeting Summarizer",
    description: "Transcribe Zoom recording and save summary/action items to Notion.",
    category: "Internal Productivity",
    integrations: ["zoom", "notion"],
    trigger: "Event-based",
    output: "Document",
    prompt: "Summarize the last 'All Hands' meeting from Zoom and create a Notion page with action items.",
    spec: buildSpec({
      id: "prod-meeting-summary",
      name: "Meeting Summarizer",
      description: "Automate notes.",
      purpose: "Knowledge capture.",
      integrations: ["zoom", "notion"],
      entities: [notionPageEntity],
      actions: [
        {
          id: "zoom.recording.get",
          name: "Get recording",
          description: "Fetch cloud recording",
          type: "READ",
          integrationId: "zoom",
          capabilityId: "zoom_meetings_list", // Proxy recording
          inputSchema: { topic: "string" },
          outputSchema: { transcript: "string" },
          writesToState: false,
        },
        {
          id: "notion.page.create",
          name: "Create summary",
          description: "Save notes",
          type: "WRITE",
          integrationId: "notion",
          capabilityId: "notion_pages_create",
          inputSchema: { title: "string", content: "string" },
          outputSchema: { page: "object" },
          writesToState: true,
        },
      ],
      views: [
        {
          id: "summary-view",
          name: "Meeting Notes",
          type: "detail",
          source: { entity: "Page", statePath: "meeting.notes" },
          fields: ["title", "attendees", "action_items"],
          actions: ["zoom.recording.get"],
        },
      ],
      query_plans: [
        {
          integrationId: "zoom",
          actionId: "zoom.recording.get",
          query: { topic: "All Hands" },
          fields: ["recording_files"],
        },
      ],
      answer_contract: {
        entity_type: "meeting_notes",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "object",
      },
      goal_plan: {
        kind: "TRANSFORMATION",
        primary_goal: "Summarize meeting",
        sub_goals: ["Get transcript", "Extract actions", "Format Notion page"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Summarize meeting",
        integrations: ["zoom", "notion"],
        objects: ["Page"],
        successCriteria: ["Page created"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: [], minimumRecords: 0 },
    }),
  },
  {
    id: "prod-ooo-coordinator",
    name: "OOO Coordinator",
    description: "Check Google Calendar for OOO events and update Slack status causing auto-replies.",
    category: "Internal Productivity",
    integrations: ["google", "slack"],
    trigger: "Time-based",
    output: "Summary",
    prompt: "Scan my calendar for 'OOO' today. If found, set my Slack status to 'Out of Office'.",
    spec: buildSpec({
      id: "prod-ooo-coordinator",
      name: "OOO Sync",
      description: "Automate status.",
      purpose: "Communication clarity.",
      integrations: ["google", "slack"],
      entities: [slackMessageEntity],
      actions: [
        {
          id: "google.calendar.ooo",
          name: "Check calendar",
          description: "Find OOO events",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_calendar_list",
          inputSchema: { timeMin: "string" },
          outputSchema: { events: "array" },
          writesToState: false,
        },
        {
          id: "slack.status.set",
          name: "Set status",
          description: "Update user profile",
          type: "WRITE",
          integrationId: "slack",
          capabilityId: "slack_messages_list", // Proxy profile set
          inputSchema: { status_text: "string", status_emoji: "string" },
          outputSchema: { ok: "boolean" },
          writesToState: true,
        },
      ],
      views: [
        {
          id: "ooo-view",
          name: "Status Sync",
          type: "detail",
          source: { entity: "Message", statePath: "user.status" },
          fields: ["current_status", "calendar_event"],
          actions: ["google.calendar.ooo"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.calendar.ooo",
          query: { q: "OOO", singleEvents: true },
          fields: ["summary", "start"],
        },
      ],
      answer_contract: {
        entity_type: "status_update",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "object",
      },
      goal_plan: {
        kind: "TRANSFORMATION",
        primary_goal: "Sync OOO",
        sub_goals: ["Check calendar", "Parse date", "Update Slack"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Set OOO",
        integrations: ["google", "slack"],
        objects: ["Message"],
        successCriteria: ["Status updated"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: [], minimumRecords: 0 },
    }),
  },
  {
    id: "prod-document-finder",
    name: "Universal Document Finder",
    description: "Search across Google Drive and Notion simultaneously to find lost docs.",
    category: "Internal Productivity",
    integrations: ["google", "notion"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Find the 'Q3 Marketing Strategy' doc. I don't remember if it's in Drive or Notion.",
    spec: buildSpec({
      id: "prod-document-finder",
      name: "Universal Search",
      description: "Stop searching twice.",
      purpose: "Information retrieval.",
      integrations: ["google", "notion"],
      entities: [notionPageEntity],
      actions: [
        {
          id: "google.drive.search",
          name: "Search Drive",
          description: "Find files",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_drive_list",
          inputSchema: { q: "string" },
          outputSchema: { files: "array" },
          writesToState: false,
        },
        {
          id: "notion.search.global",
          name: "Search Notion",
          description: "Find pages",
          type: "READ",
          integrationId: "notion",
          capabilityId: "notion_pages_search",
          inputSchema: { query: "string" },
          outputSchema: { results: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "search-view",
          name: "Search Results",
          type: "table",
          source: { entity: "Page", statePath: "search.results" },
          fields: ["title", "source", "link", "last_modified"],
          actions: ["google.drive.search"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.drive.search",
          query: { q: "name contains 'Marketing Strategy'" },
          fields: ["name", "webViewLink"],
        },
        {
          integrationId: "notion",
          actionId: "notion.search.global",
          query: { query: "Marketing Strategy" },
          fields: ["title", "url"],
        },
      ],
      answer_contract: {
        entity_type: "search_result",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Find document",
        sub_goals: ["Search Drive", "Search Notion", "Merge results"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Find doc",
        integrations: ["google", "notion"],
        objects: ["Page"],
        successCriteria: ["Document found"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: [], minimumRecords: 0 },
    }),
  },
  {
    id: "prod-it-helpdesk",
    name: "IT Helpdesk Auto-Triage",
    description: "Convert Slack posts in #help-it into Linear issues automatically.",
    category: "Internal Productivity",
    integrations: ["slack", "linear"],
    trigger: "Event-based",
    output: "Summary",
    prompt: "Listen to #help-it. When a new post appears, create a Linear ticket in 'IT Triage'.",
    spec: buildSpec({
      id: "prod-it-helpdesk",
      name: "IT Triage",
      description: "Automate helpdesk.",
      purpose: "Ops efficiency.",
      integrations: ["slack", "linear"],
      entities: [slackMessageEntity, linearIssueEntity],
      actions: [
        {
          id: "slack.channel.history",
          name: "Get new requests",
          description: "Fetch channel posts",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_messages_list",
          inputSchema: { channel: "string" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
        {
          id: "linear.issue.create_it",
          name: "Create ticket",
          description: "File to IT team",
          type: "WRITE",
          integrationId: "linear",
          capabilityId: "linear_issues_list", // Proxy create
          inputSchema: { title: "string" },
          outputSchema: { issue: "object" },
          writesToState: true,
        },
      ],
      views: [
        {
          id: "triage-it-view",
          name: "IT Requests",
          type: "table",
          source: { entity: "Issue", statePath: "it.tickets" },
          fields: ["requestor", "issue_title", "status"],
          actions: ["linear.issue.create_it"],
        },
      ],
      query_plans: [
        {
          integrationId: "slack",
          actionId: "slack.channel.history",
          query: { channel: "help-it", limit: 10 },
          fields: ["text", "user"],
        },
      ],
      answer_contract: {
        entity_type: "it_ticket",
        required_constraints: [],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "TRANSFORMATION",
        primary_goal: "Triage IT requests",
        sub_goals: ["Monitor channel", "Extract details", "File ticket"],
        constraints: [],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "File IT tickets",
        integrations: ["slack", "linear"],
        objects: ["Message", "Issue"],
        successCriteria: ["Ticket created"],
        forbiddenOutputs: ["dummy"],
      }),
      dataReadiness: { requiredEntities: [], minimumRecords: 0 },
    }),
  },
];
export const useCaseCategories: UseCaseCategory[] = [
  "Engineering & Product",
  "Revenue, Sales & CRM",
  "Customer Support & Success",
  "Operations & Finance",
  "Executive & Leadership",
  "Internal Productivity",
];

export const useCasesByCategory = useCaseCategories.map((category) => ({
  category,
  items: useCases.filter((tool) => tool.category === category),
}));
