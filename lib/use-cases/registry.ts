import { createEmptyToolSpec, type IntegrationId, type ToolSystemSpec } from "@/lib/toolos/spec";
import { getCapabilitiesForIntegration } from "@/lib/capabilities/registry";

export type UseCaseCategory =
  | "Featured"
  | "Engineering"
  | "Design"
  | "Marketing"
  | "Sales"
  | "Operations"
  | "Leadership / Exec"
  | "Personal (Consumer)";

export type UseCaseTrigger = "Prompt-based" | "Event-based" | "Time-based";
export type UseCaseOutput = "Table" | "Summary" | "Alert" | "Document";

export type UseCaseDefinition = {
  id: string;
  name: string;
  description: string;
  category: UseCaseCategory;
  integrations: IntegrationId[];
  trigger: UseCaseTrigger;
  output: UseCaseOutput;
  prompt: string;
  spec: ToolSystemSpec;
};

const integrationCapabilities = (id: IntegrationId) =>
  getCapabilitiesForIntegration(id).map((cap) => cap.id);

const buildSpec = (input: {
  id: string;
  name: string;
  description: string;
  purpose: string;
  integrations: IntegrationId[];
  entities: ToolSystemSpec["entities"];
  actions: ToolSystemSpec["actions"];
  views: ToolSystemSpec["views"];
  query_plans: ToolSystemSpec["query_plans"];
  answer_contract: ToolSystemSpec["answer_contract"];
  goal_plan: ToolSystemSpec["goal_plan"];
  intent_contract: ToolSystemSpec["intent_contract"];
  triggers?: ToolSystemSpec["triggers"];
  initialFetch?: ToolSystemSpec["initialFetch"];
  dataReadiness?: ToolSystemSpec["dataReadiness"];
}) => {
  const base = createEmptyToolSpec({
    id: input.id,
    name: input.name,
    purpose: input.purpose,
    description: input.description,
    sourcePrompt: input.purpose,
  });

  return {
    ...base,
    integrations: input.integrations.map((id) => ({
      id,
      capabilities: integrationCapabilities(id),
    })),
    entities: input.entities,
    actions: input.actions,
    views: input.views,
    triggers: input.triggers ?? [],
    query_plans: input.query_plans,
    answer_contract: input.answer_contract,
    goal_plan: input.goal_plan,
    intent_contract: input.intent_contract,
    initialFetch: input.initialFetch,
    dataReadiness: input.dataReadiness,
    automations: {
      enabled: true,
      capabilities: {
        canRunWithoutUI: true,
        supportedTriggers: (input.triggers ?? []).map((t) => t.type),
        maxFrequency: 1440,
        safetyConstraints: ["approval_required_for_writes"],
      },
    },
    observability: {
      executionTimeline: true,
      recentRuns: true,
      errorStates: true,
      integrationHealth: true,
      manualRetryControls: true,
    },
  };
};

const buildIntentContract = (input: {
  userGoal: string;
  integrations: string[];
  objects?: string[];
  filters?: string[];
  successCriteria?: string[];
  forbiddenOutputs?: string[];
}) => ({
  userGoal: input.userGoal,
  successCriteria: input.successCriteria ?? [],
  implicitConstraints: [],
  hiddenStateRequirements: [],
  subjectivityScore: 0.35,
  heuristics: [],
  requiredEntities: {
    integrations: input.integrations,
    objects: input.objects ?? [],
    filters: input.filters ?? [],
  },
  forbiddenOutputs: input.forbiddenOutputs ?? [],
  acceptableFallbacks: [],
});

const emailEntity = {
  name: "Email",
  sourceIntegration: "google" as const,
  identifiers: ["id", "threadId"],
  supportedActions: ["google.gmail.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "from", type: "string" },
    { name: "subject", type: "string" },
    { name: "snippet", type: "string" },
    { name: "internalDate", type: "string" },
    { name: "labelIds", type: "array" },
  ],
};

const slackMessageEntity = {
  name: "Message",
  sourceIntegration: "slack" as const,
  identifiers: ["id", "timestamp"],
  supportedActions: ["slack.messages.search", "slack.messages.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "channel", type: "string" },
    { name: "user", type: "string" },
    { name: "text", type: "string" },
    { name: "timestamp", type: "string" },
  ],
};

const githubIssueEntity = {
  name: "Issue",
  sourceIntegration: "github" as const,
  identifiers: ["id", "number"],
  supportedActions: ["github.issues.search", "github.issues.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "number", type: "number" },
    { name: "title", type: "string" },
    { name: "state", type: "string" },
    { name: "url", type: "string" },
  ],
};

const linearIssueEntity = {
  name: "Issue",
  sourceIntegration: "linear" as const,
  identifiers: ["id"],
  supportedActions: ["linear.issues.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "title", type: "string" },
    { name: "state", type: "string" },
    { name: "assignee", type: "string" },
    { name: "priority", type: "number" },
  ],
};

const notionPageEntity = {
  name: "Page",
  sourceIntegration: "notion" as const,
  identifiers: ["id"],
  supportedActions: ["notion.pages.search"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "title", type: "string" },
    { name: "lastEdited", type: "string" },
    { name: "url", type: "string" },
  ],
};

const driveFileEntity = {
  name: "File",
  sourceIntegration: "google" as const,
  identifiers: ["id"],
  supportedActions: ["google.drive.list"],
  fields: [
    { name: "id", type: "string", required: true },
    { name: "name", type: "string" },
    { name: "mimeType", type: "string" },
    { name: "modifiedTime", type: "string" },
    { name: "webViewLink", type: "string" },
  ],
};

const useCases: UseCaseDefinition[] = [
  {
    id: "featured-inbox-priority-radar",
    name: "Inbox Priority Radar",
    description: "Surface the most urgent emails with context-rich previews.",
    category: "Featured",
    integrations: ["google"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Show my most urgent emails from the last 48 hours with sender, subject, and snippet.",
    spec: buildSpec({
      id: "featured-inbox-priority-radar",
      name: "Inbox Priority Radar",
      description: "Prioritize urgent emails with the latest context.",
      purpose: "Identify urgent inbound emails from the last 48 hours.",
      integrations: ["google"],
      entities: [emailEntity],
      actions: [
        {
          id: "google.gmail.priority",
          name: "List recent priority emails",
          description: "Fetch high priority emails from Gmail",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list",
          inputSchema: { query: "string", maxResults: "number" },
          outputSchema: { emails: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "inbox-priority-table",
          name: "Priority Inbox",
          type: "table",
          source: { entity: "Email", statePath: "google.emails" },
          fields: ["from", "subject", "snippet", "internalDate"],
          actions: ["google.gmail.priority"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.gmail.priority",
          query: { query: "newer_than:2d label:important" },
          fields: ["from", "subject", "snippet", "internalDate"],
          max_results: 20,
        },
      ],
      answer_contract: {
        entity_type: "email",
        required_constraints: [{ field: "labelIds", operator: "semantic_contains", value: "important" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
        result_shape: {
          kind: "list",
          fields: ["from", "subject", "snippet", "internalDate"],
          order_by: "internalDate",
          order_direction: "desc",
          limit: 20,
        },
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Return urgent, recent emails",
        sub_goals: ["Sort by recency", "Include sender and snippet"],
        constraints: ["Last 48 hours", "High priority labels"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Find high priority emails",
        integrations: ["google"],
        objects: ["Email"],
        filters: ["priority", "last 48 hours"],
        successCriteria: ["At least one recent email", "Includes sender and snippet"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      initialFetch: {
        entity: "Email",
        integrationId: "google",
        actionId: "google.gmail.priority",
        limit: 20,
        order_by: "internalDate",
        order_direction: "desc",
      },
      dataReadiness: { requiredEntities: ["Email"], minimumRecords: 1 },
    }),
  },
  {
    id: "featured-daily-focus-digest",
    name: "Daily Focus Digest",
    description: "A crisp, daily inbox briefing of what matters most.",
    category: "Featured",
    integrations: ["google"],
    trigger: "Time-based",
    output: "Summary",
    prompt: "Summarize the most important emails from the last 24 hours.",
    spec: buildSpec({
      id: "featured-daily-focus-digest",
      name: "Daily Focus Digest",
      description: "Generate a daily digest of important emails.",
      purpose: "Create a daily email digest with key threads.",
      integrations: ["google"],
      entities: [emailEntity],
      actions: [
        {
          id: "google.gmail.digest",
          name: "List daily emails",
          description: "Fetch daily emails",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list",
          inputSchema: { query: "string", maxResults: "number" },
          outputSchema: { emails: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "daily-digest-table",
          name: "Daily Digest",
          type: "table",
          source: { entity: "Email", statePath: "google.daily" },
          fields: ["from", "subject", "snippet", "internalDate"],
          actions: ["google.gmail.digest"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.gmail.digest",
          query: { query: "newer_than:1d -category:social" },
          fields: ["from", "subject", "snippet", "internalDate"],
          max_results: 25,
        },
      ],
      answer_contract: {
        entity_type: "email",
        required_constraints: [{ field: "internalDate", operator: "semantic_contains", value: "last 24 hours" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
        result_shape: {
          kind: "list",
          fields: ["from", "subject", "snippet", "internalDate"],
          order_by: "internalDate",
          order_direction: "desc",
          limit: 25,
        },
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Surface daily emails worth attention",
        sub_goals: ["Filter out low-signal categories", "Sort by recency"],
        constraints: ["Last 24 hours"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Daily email digest",
        integrations: ["google"],
        objects: ["Email"],
        filters: ["last 24 hours"],
        successCriteria: ["Recent emails returned", "Digest is limited"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      triggers: [
        {
          id: "daily-digest-cron",
          name: "Daily digest run",
          type: "cron",
          condition: { cron: "0 8 * * 1-5" },
          actionId: "google.gmail.digest",
          enabled: true,
        },
      ],
      initialFetch: {
        entity: "Email",
        integrationId: "google",
        actionId: "google.gmail.digest",
        limit: 25,
        order_by: "internalDate",
        order_direction: "desc",
      },
      dataReadiness: { requiredEntities: ["Email"], minimumRecords: 1 },
    }),
  },
  {
    id: "consumer-meeting-notes-extractor",
    name: "Meeting Notes Extractor",
    description: "Collect the latest meeting notes and extract highlights.",
    category: "Personal (Consumer)",
    integrations: ["google"],
    trigger: "Prompt-based",
    output: "Summary",
    prompt: "List the most recently updated meeting notes docs with titles and update times.",
    spec: buildSpec({
      id: "consumer-meeting-notes-extractor",
      name: "Meeting Notes Extractor",
      description: "Extract highlights from the most recent meeting notes.",
      purpose: "Find latest meeting notes in Google Drive.",
      integrations: ["google"],
      entities: [driveFileEntity],
      actions: [
        {
          id: "google.drive.meeting-notes",
          name: "List recent meeting notes",
          description: "Find meeting notes in Google Drive",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_drive_list",
          inputSchema: { query: "string", pageSize: "number" },
          outputSchema: { files: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "meeting-notes-table",
          name: "Recent Meeting Notes",
          type: "table",
          source: { entity: "File", statePath: "google.meeting_notes" },
          fields: ["name", "modifiedTime", "webViewLink"],
          actions: ["google.drive.meeting-notes"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.drive.meeting-notes",
          query: { q: "name contains 'Meeting' and mimeType contains 'document'" },
          fields: ["name", "modifiedTime", "webViewLink"],
          max_results: 15,
        },
      ],
      answer_contract: {
        entity_type: "file",
        required_constraints: [{ field: "name", operator: "semantic_contains", value: "Meeting" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
        result_shape: {
          kind: "list",
          fields: ["name", "modifiedTime", "webViewLink"],
          order_by: "modifiedTime",
          order_direction: "desc",
          limit: 15,
        },
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "List recent meeting notes documents",
        sub_goals: ["Return title and last updated time"],
        constraints: ["Docs only", "Most recent first"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Recent meeting notes",
        integrations: ["google"],
        objects: ["File"],
        filters: ["meeting notes", "recently updated"],
        successCriteria: ["Latest docs returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      initialFetch: {
        entity: "File",
        integrationId: "google",
        actionId: "google.drive.meeting-notes",
        limit: 15,
        order_by: "modifiedTime",
        order_direction: "desc",
      },
      dataReadiness: { requiredEntities: ["File"], minimumRecords: 1 },
    }),
  },
  {
    id: "consumer-weekly-goals-review",
    name: "Weekly Goals Review",
    description: "Track your top goals and open blockers each week.",
    category: "Personal (Consumer)",
    integrations: ["linear", "notion"],
    trigger: "Time-based",
    output: "Table",
    prompt: "Review my open goals and blockers for the week.",
    spec: buildSpec({
      id: "consumer-weekly-goals-review",
      name: "Weekly Goals Review",
      description: "Review open goals and blockers.",
      purpose: "Summarize weekly goals and blockers across Linear and Notion.",
      integrations: ["linear", "notion"],
      entities: [linearIssueEntity, notionPageEntity],
      actions: [
        {
          id: "linear.weekly.goals",
          name: "List weekly Linear issues",
          description: "Fetch open Linear issues",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list",
          inputSchema: { state: "string", limit: "number" },
          outputSchema: { issues: "array" },
          writesToState: false,
        },
        {
          id: "notion.weekly.goals",
          name: "Search Notion goals",
          description: "Find goals in Notion",
          type: "READ",
          integrationId: "notion",
          capabilityId: "notion_pages_search",
          inputSchema: { query: "string" },
          outputSchema: { pages: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "weekly-goals-linear",
          name: "Linear Goals",
          type: "table",
          source: { entity: "Issue", statePath: "linear.goals" },
          fields: ["title", "state", "assignee", "priority"],
          actions: ["linear.weekly.goals"],
        },
        {
          id: "weekly-goals-notion",
          name: "Notion Goals",
          type: "table",
          source: { entity: "Page", statePath: "notion.goals" },
          fields: ["title", "lastEdited", "url"],
          actions: ["notion.weekly.goals"],
        },
      ],
      query_plans: [
        {
          integrationId: "linear",
          actionId: "linear.weekly.goals",
          query: { includeArchived: false },
          fields: ["title", "state", "assignee", "priority"],
          max_results: 20,
        },
        {
          integrationId: "notion",
          actionId: "notion.weekly.goals",
          query: { query: "goal OR OKR" },
          fields: ["title", "lastEdited", "url"],
          max_results: 10,
        },
      ],
      answer_contract: {
        entity_type: "issue",
        required_constraints: [{ field: "state", operator: "semantic_contains", value: "open" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
        result_shape: {
          kind: "list",
          fields: ["title", "state", "assignee", "priority"],
          limit: 20,
        },
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Review open goals and blockers",
        sub_goals: ["List open Linear issues", "Pull relevant Notion pages"],
        constraints: ["Open only"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Weekly goals review",
        integrations: ["linear", "notion"],
        objects: ["Issue", "Page"],
        filters: ["open", "weekly"],
        successCriteria: ["Open goals returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      triggers: [
        {
          id: "weekly-goals-cron",
          name: "Weekly goals review",
          type: "cron",
          condition: { cron: "0 9 * * MON" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["Issue", "Page"], minimumRecords: 1 },
    }),
  },
  {
    id: "consumer-travel-itinerary-intel",
    name: "Travel Itinerary Intelligence",
    description: "Aggregate upcoming travel confirmations in one view.",
    category: "Personal (Consumer)",
    integrations: ["google"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Find my upcoming travel confirmations and show dates, senders, and subjects.",
    spec: buildSpec({
      id: "consumer-travel-itinerary-intel",
      name: "Travel Itinerary Intelligence",
      description: "Aggregate upcoming travel confirmations.",
      purpose: "Find travel-related emails for upcoming trips.",
      integrations: ["google"],
      entities: [emailEntity],
      actions: [
        {
          id: "google.gmail.travel",
          name: "Search travel emails",
          description: "Fetch travel-related emails",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_gmail_list",
          inputSchema: { query: "string", maxResults: "number" },
          outputSchema: { emails: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "travel-table",
          name: "Travel Confirmations",
          type: "table",
          source: { entity: "Email", statePath: "google.travel" },
          fields: ["from", "subject", "snippet", "internalDate"],
          actions: ["google.gmail.travel"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.gmail.travel",
          query: { query: "itinerary OR booking OR reservation newer_than:30d" },
          fields: ["from", "subject", "snippet", "internalDate"],
          max_results: 25,
        },
      ],
      answer_contract: {
        entity_type: "email",
        required_constraints: [{ field: "subject", operator: "semantic_contains", value: "reservation" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
        result_shape: {
          kind: "list",
          fields: ["from", "subject", "snippet", "internalDate"],
          order_by: "internalDate",
          order_direction: "desc",
          limit: 25,
        },
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "List upcoming travel confirmations",
        sub_goals: ["Identify travel keywords", "Sort by recency"],
        constraints: ["Last 30 days"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Travel itinerary emails",
        integrations: ["google"],
        objects: ["Email"],
        filters: ["travel confirmations", "last 30 days"],
        successCriteria: ["Travel confirmations returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      dataReadiness: { requiredEntities: ["Email"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-sales-pipeline-intel",
    name: "Sales Pipeline Intelligence",
    description: "Monitor live deal momentum and high-risk opportunities.",
    category: "Sales",
    integrations: ["slack", "notion"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Show the latest high-risk deals and sales updates.",
    spec: buildSpec({
      id: "enterprise-sales-pipeline-intel",
      name: "Sales Pipeline Intelligence",
      description: "Track deal updates and risk signals.",
      purpose: "Monitor deal momentum from Notion and Slack updates.",
      integrations: ["slack", "notion"],
      entities: [slackMessageEntity, notionPageEntity],
      actions: [
        {
          id: "slack.sales.updates",
          name: "Search sales updates",
          description: "Fetch sales updates from Slack",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_search_messages",
          inputSchema: { query: "string", count: "number" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
        {
          id: "notion.deals.search",
          name: "Search sales pages",
          description: "Find sales pages in Notion",
          type: "READ",
          integrationId: "notion",
          capabilityId: "notion_pages_search",
          inputSchema: { query: "string" },
          outputSchema: { pages: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "sales-slack-table",
          name: "Slack Sales Updates",
          type: "table",
          source: { entity: "Message", statePath: "slack.sales_updates" },
          fields: ["channel", "user", "text", "timestamp"],
          actions: ["slack.sales.updates"],
        },
        {
          id: "sales-notion-table",
          name: "Notion Deal Pages",
          type: "table",
          source: { entity: "Page", statePath: "notion.sales_pages" },
          fields: ["title", "lastEdited", "url"],
          actions: ["notion.deals.search"],
        },
      ],
      query_plans: [
        {
          integrationId: "slack",
          actionId: "slack.sales.updates",
          query: { query: "deal OR pipeline OR renewal" },
          fields: ["channel", "user", "text", "timestamp"],
          max_results: 20,
        },
        {
          integrationId: "notion",
          actionId: "notion.deals.search",
          query: { query: "deal" },
          fields: ["title", "lastEdited", "url"],
          max_results: 10,
        },
      ],
      answer_contract: {
        entity_type: "message",
        required_constraints: [{ field: "text", operator: "semantic_contains", value: "deal" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
        result_shape: {
          kind: "list",
          fields: ["channel", "user", "text", "timestamp"],
          limit: 20,
        },
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Surface high-risk sales pipeline updates",
        sub_goals: ["Collect sales updates", "Highlight deal changes"],
        constraints: ["Recent updates"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Sales pipeline updates",
        integrations: ["slack", "notion"],
        objects: ["Message", "Page"],
        filters: ["deal updates", "pipeline"],
        successCriteria: ["Recent sales messages", "Deal pages found"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      dataReadiness: { requiredEntities: ["Message", "Page"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-engineering-velocity",
    name: "Engineering Velocity & Risk Monitor",
    description: "Track delivery velocity and emerging risks across GitHub and Linear.",
    category: "Engineering",
    integrations: ["github", "linear"],
    trigger: "Time-based",
    output: "Table",
    prompt: "Summarize current engineering velocity and risks.",
    spec: buildSpec({
      id: "enterprise-engineering-velocity",
      name: "Engineering Velocity & Risk Monitor",
      description: "Monitor delivery velocity and risk signals.",
      purpose: "Track open issues and risks across GitHub and Linear.",
      integrations: ["github", "linear"],
      entities: [githubIssueEntity, linearIssueEntity],
      actions: [
        {
          id: "github.issues.risk",
          name: "Search GitHub risk issues",
          description: "Fetch risk-tagged GitHub issues",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_issues_search",
          inputSchema: { query: "string" },
          outputSchema: { issues: "array" },
          writesToState: false,
        },
        {
          id: "linear.issues.risk",
          name: "List Linear high priority issues",
          description: "Fetch high priority Linear issues",
          type: "READ",
          integrationId: "linear",
          capabilityId: "linear_issues_list",
          inputSchema: { includeArchived: "boolean" },
          outputSchema: { issues: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "github-risk-table",
          name: "GitHub Risk Issues",
          type: "table",
          source: { entity: "Issue", statePath: "github.risk_issues" },
          fields: ["title", "state", "url"],
          actions: ["github.issues.risk"],
        },
        {
          id: "linear-risk-table",
          name: "Linear Risk Issues",
          type: "table",
          source: { entity: "Issue", statePath: "linear.risk_issues" },
          fields: ["title", "state", "assignee", "priority"],
          actions: ["linear.issues.risk"],
        },
      ],
      query_plans: [
        {
          integrationId: "github",
          actionId: "github.issues.risk",
          query: { q: "is:issue is:open label:risk" },
          fields: ["title", "state", "url"],
          max_results: 25,
        },
        {
          integrationId: "linear",
          actionId: "linear.issues.risk",
          query: { includeArchived: false },
          fields: ["title", "state", "assignee", "priority"],
          max_results: 25,
        },
      ],
      answer_contract: {
        entity_type: "issue",
        required_constraints: [{ field: "state", operator: "semantic_contains", value: "open" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
        result_shape: {
          kind: "list",
          fields: ["title", "state", "assignee", "priority"],
          limit: 25,
        },
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Track engineering velocity and risks",
        sub_goals: ["Collect open GitHub issues", "Collect high priority Linear issues"],
        constraints: ["Open only"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Engineering velocity and risk",
        integrations: ["github", "linear"],
        objects: ["Issue"],
        filters: ["risk", "open"],
        successCriteria: ["Open issues returned", "High priority risks visible"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      triggers: [
        {
          id: "engineering-weekly",
          name: "Weekly engineering pulse",
          type: "cron",
          condition: { cron: "0 9 * * MON" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-exec-weekly-review",
    name: "Executive Weekly Business Review",
    description: "Pull leadership-grade updates from Slack and shared docs.",
    category: "Leadership / Exec",
    integrations: ["slack", "google"],
    trigger: "Time-based",
    output: "Summary",
    prompt: "Compile a weekly executive review from key updates.",
    spec: buildSpec({
      id: "enterprise-exec-weekly-review",
      name: "Executive Weekly Business Review",
      description: "Summarize weekly executive updates.",
      purpose: "Compile key updates from Slack and Drive.",
      integrations: ["slack", "google"],
      entities: [slackMessageEntity, driveFileEntity],
      actions: [
        {
          id: "slack.exec.updates",
          name: "Search executive updates",
          description: "Fetch exec updates from Slack",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_search_messages",
          inputSchema: { query: "string", count: "number" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
        {
          id: "google.drive.exec-docs",
          name: "List exec docs",
          description: "Fetch executive docs from Drive",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_drive_list",
          inputSchema: { query: "string", pageSize: "number" },
          outputSchema: { files: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "exec-slack-table",
          name: "Executive Updates",
          type: "table",
          source: { entity: "Message", statePath: "slack.exec_updates" },
          fields: ["channel", "user", "text", "timestamp"],
          actions: ["slack.exec.updates"],
        },
        {
          id: "exec-docs-table",
          name: "Executive Docs",
          type: "table",
          source: { entity: "File", statePath: "google.exec_docs" },
          fields: ["name", "modifiedTime", "webViewLink"],
          actions: ["google.drive.exec-docs"],
        },
      ],
      query_plans: [
        {
          integrationId: "slack",
          actionId: "slack.exec.updates",
          query: { query: "exec update OR weekly review" },
          fields: ["channel", "user", "text", "timestamp"],
          max_results: 20,
        },
        {
          integrationId: "google",
          actionId: "google.drive.exec-docs",
          query: { q: "name contains 'Exec' or name contains 'Board' and mimeType contains 'document'" },
          fields: ["name", "modifiedTime", "webViewLink"],
          max_results: 10,
        },
      ],
      answer_contract: {
        entity_type: "message",
        required_constraints: [{ field: "text", operator: "semantic_contains", value: "update" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Deliver weekly executive review",
        sub_goals: ["Collect executive Slack updates", "Gather executive docs"],
        constraints: ["Last 7 days"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Executive weekly review",
        integrations: ["slack", "google"],
        objects: ["Message", "File"],
        filters: ["weekly", "exec updates"],
        successCriteria: ["Exec updates found", "Docs found"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      triggers: [
        {
          id: "exec-weekly-cron",
          name: "Executive weekly review",
          type: "cron",
          condition: { cron: "0 8 * * MON" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["Message", "File"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-security-incident",
    name: "Security & Incident Detection",
    description: "Detect security and incident signals across Slack and GitHub.",
    category: "Operations",
    integrations: ["slack", "github"],
    trigger: "Event-based",
    output: "Alert",
    prompt: "Detect security and incident signals from Slack and GitHub.",
    spec: buildSpec({
      id: "enterprise-security-incident",
      name: "Security & Incident Detection",
      description: "Detect security and incident signals.",
      purpose: "Identify security incidents in Slack and GitHub.",
      integrations: ["slack", "github"],
      entities: [slackMessageEntity, githubIssueEntity],
      actions: [
        {
          id: "slack.security.alerts",
          name: "Search incident messages",
          description: "Fetch incident messages from Slack",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_search_messages",
          inputSchema: { query: "string", count: "number" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
        {
          id: "github.security.issues",
          name: "Search security issues",
          description: "Fetch security issues from GitHub",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_issues_search",
          inputSchema: { query: "string" },
          outputSchema: { issues: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "security-slack",
          name: "Incident Slack Signals",
          type: "table",
          source: { entity: "Message", statePath: "slack.security_signals" },
          fields: ["channel", "user", "text", "timestamp"],
          actions: ["slack.security.alerts"],
        },
        {
          id: "security-github",
          name: "Security Issues",
          type: "table",
          source: { entity: "Issue", statePath: "github.security_issues" },
          fields: ["title", "state", "url"],
          actions: ["github.security.issues"],
        },
      ],
      query_plans: [
        {
          integrationId: "slack",
          actionId: "slack.security.alerts",
          query: { query: "incident OR outage OR security" },
          fields: ["channel", "user", "text", "timestamp"],
          max_results: 20,
        },
        {
          integrationId: "github",
          actionId: "github.security.issues",
          query: { q: "is:issue is:open label:security" },
          fields: ["title", "state", "url"],
          max_results: 20,
        },
      ],
      answer_contract: {
        entity_type: "message",
        required_constraints: [{ field: "text", operator: "semantic_contains", value: "incident" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Detect security and incident signals",
        sub_goals: ["Find incident messages", "Find security issues"],
        constraints: ["Open incidents"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Security incident detection",
        integrations: ["slack", "github"],
        objects: ["Message", "Issue"],
        filters: ["incident", "security"],
        successCriteria: ["Incident signals detected"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      triggers: [
        {
          id: "security-event",
          name: "Incident signal trigger",
          type: "integration_event",
          condition: { event: "message_posted", keyword: "incident" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["Message", "Issue"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-feedback-intelligence",
    name: "Customer Feedback Intelligence",
    description: "Aggregate customer feedback signals from Slack and Notion.",
    category: "Marketing",
    integrations: ["slack", "notion"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Aggregate customer feedback signals from Slack and Notion.",
    spec: buildSpec({
      id: "enterprise-feedback-intelligence",
      name: "Customer Feedback Intelligence",
      description: "Aggregate customer feedback signals.",
      purpose: "Compile feedback from Slack and Notion.",
      integrations: ["slack", "notion"],
      entities: [slackMessageEntity, notionPageEntity],
      actions: [
        {
          id: "slack.feedback.search",
          name: "Search feedback messages",
          description: "Fetch feedback messages from Slack",
          type: "READ",
          integrationId: "slack",
          capabilityId: "slack_search_messages",
          inputSchema: { query: "string", count: "number" },
          outputSchema: { messages: "array" },
          writesToState: false,
        },
        {
          id: "notion.feedback.search",
          name: "Search feedback pages",
          description: "Find feedback pages in Notion",
          type: "READ",
          integrationId: "notion",
          capabilityId: "notion_pages_search",
          inputSchema: { query: "string" },
          outputSchema: { pages: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "feedback-slack-table",
          name: "Slack Feedback",
          type: "table",
          source: { entity: "Message", statePath: "slack.feedback" },
          fields: ["channel", "user", "text", "timestamp"],
          actions: ["slack.feedback.search"],
        },
        {
          id: "feedback-notion-table",
          name: "Notion Feedback",
          type: "table",
          source: { entity: "Page", statePath: "notion.feedback" },
          fields: ["title", "lastEdited", "url"],
          actions: ["notion.feedback.search"],
        },
      ],
      query_plans: [
        {
          integrationId: "slack",
          actionId: "slack.feedback.search",
          query: { query: "feedback OR request OR complaint" },
          fields: ["channel", "user", "text", "timestamp"],
          max_results: 20,
        },
        {
          integrationId: "notion",
          actionId: "notion.feedback.search",
          query: { query: "feedback" },
          fields: ["title", "lastEdited", "url"],
          max_results: 10,
        },
      ],
      answer_contract: {
        entity_type: "message",
        required_constraints: [{ field: "text", operator: "semantic_contains", value: "feedback" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Aggregate customer feedback",
        sub_goals: ["Collect Slack feedback", "Collect Notion feedback pages"],
        constraints: ["Recent feedback"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Customer feedback aggregation",
        integrations: ["slack", "notion"],
        objects: ["Message", "Page"],
        filters: ["feedback"],
        successCriteria: ["Feedback signals returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      dataReadiness: { requiredEntities: ["Message", "Page"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-board-meeting-intel",
    name: "Board Meeting Intelligence",
    description: "Centralize board materials and recent updates.",
    category: "Leadership / Exec",
    integrations: ["google"],
    trigger: "Prompt-based",
    output: "Document",
    prompt: "List the latest board materials and summaries.",
    spec: buildSpec({
      id: "enterprise-board-meeting-intel",
      name: "Board Meeting Intelligence",
      description: "Centralize board materials and updates.",
      purpose: "Find latest board materials in Drive.",
      integrations: ["google"],
      entities: [driveFileEntity],
      actions: [
        {
          id: "google.drive.board",
          name: "List board materials",
          description: "Fetch board docs and slides",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_drive_list",
          inputSchema: { query: "string", pageSize: "number" },
          outputSchema: { files: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "board-materials-table",
          name: "Board Materials",
          type: "table",
          source: { entity: "File", statePath: "google.board_materials" },
          fields: ["name", "mimeType", "modifiedTime", "webViewLink"],
          actions: ["google.drive.board"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.drive.board",
          query: { q: "name contains 'Board' or name contains 'QBR'" },
          fields: ["name", "mimeType", "modifiedTime", "webViewLink"],
          max_results: 15,
        },
      ],
      answer_contract: {
        entity_type: "file",
        required_constraints: [{ field: "name", operator: "semantic_contains", value: "Board" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "List board meeting materials",
        sub_goals: ["Find recent board docs", "Include slides and docs"],
        constraints: ["Most recent first"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Board materials",
        integrations: ["google"],
        objects: ["File"],
        filters: ["board", "qbr"],
        successCriteria: ["Board materials returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      dataReadiness: { requiredEntities: ["File"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-investor-update-intel",
    name: "Investor Update Intelligence",
    description: "Assemble investor updates and progress signals.",
    category: "Leadership / Exec",
    integrations: ["google"],
    trigger: "Time-based",
    output: "Document",
    prompt: "Compile the latest investor update materials.",
    spec: buildSpec({
      id: "enterprise-investor-update-intel",
      name: "Investor Update Intelligence",
      description: "Assemble investor updates.",
      purpose: "Collect investor update materials from Drive.",
      integrations: ["google"],
      entities: [driveFileEntity],
      actions: [
        {
          id: "google.drive.investor",
          name: "List investor updates",
          description: "Fetch investor update docs",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_drive_list",
          inputSchema: { query: "string", pageSize: "number" },
          outputSchema: { files: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "investor-docs-table",
          name: "Investor Update Materials",
          type: "table",
          source: { entity: "File", statePath: "google.investor_updates" },
          fields: ["name", "modifiedTime", "webViewLink"],
          actions: ["google.drive.investor"],
        },
      ],
      query_plans: [
        {
          integrationId: "google",
          actionId: "google.drive.investor",
          query: { q: "name contains 'Investor' or name contains 'Update'" },
          fields: ["name", "modifiedTime", "webViewLink"],
          max_results: 15,
        },
      ],
      answer_contract: {
        entity_type: "file",
        required_constraints: [{ field: "name", operator: "semantic_contains", value: "Investor" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Assemble investor update materials",
        sub_goals: ["Collect latest investor docs"],
        constraints: ["Most recent first"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Investor update materials",
        integrations: ["google"],
        objects: ["File"],
        filters: ["investor", "update"],
        successCriteria: ["Investor materials returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      triggers: [
        {
          id: "investor-monthly",
          name: "Monthly investor update",
          type: "cron",
          condition: { cron: "0 8 1 * *" },
          enabled: true,
        },
      ],
      dataReadiness: { requiredEntities: ["File"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-codebase-health",
    name: "Codebase Health & Technical Debt Analyzer",
    description: "Identify aging issues, backlog debt, and neglected repos.",
    category: "Engineering",
    integrations: ["github"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "Identify aging issues and technical debt hotspots.",
    spec: buildSpec({
      id: "enterprise-codebase-health",
      name: "Codebase Health & Technical Debt Analyzer",
      description: "Identify technical debt hotspots.",
      purpose: "Analyze aging GitHub issues for technical debt.",
      integrations: ["github"],
      entities: [githubIssueEntity],
      actions: [
        {
          id: "github.debt.issues",
          name: "Search stale issues",
          description: "Fetch long-running issues",
          type: "READ",
          integrationId: "github",
          capabilityId: "github_issues_search",
          inputSchema: { query: "string" },
          outputSchema: { issues: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "debt-issues-table",
          name: "Stale Issues",
          type: "table",
          source: { entity: "Issue", statePath: "github.debt_issues" },
          fields: ["title", "state", "url"],
          actions: ["github.debt.issues"],
        },
      ],
      query_plans: [
        {
          integrationId: "github",
          actionId: "github.debt.issues",
          query: { q: "is:issue is:open sort:updated-asc" },
          fields: ["title", "state", "url"],
          max_results: 25,
        },
      ],
      answer_contract: {
        entity_type: "issue",
        required_constraints: [{ field: "state", operator: "semantic_contains", value: "open" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "ANALYSIS",
        primary_goal: "Identify technical debt hotspots",
        sub_goals: ["Find stale open issues"],
        constraints: ["Oldest updated first"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Codebase health",
        integrations: ["github"],
        objects: ["Issue"],
        filters: ["stale", "open"],
        successCriteria: ["Stale issues returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      dataReadiness: { requiredEntities: ["Issue"], minimumRecords: 1 },
    }),
  },
  {
    id: "enterprise-design-sprint-insights",
    name: "Design Sprint Asset Tracker",
    description: "Track design sprint artifacts across Notion and Drive.",
    category: "Design",
    integrations: ["notion", "google"],
    trigger: "Prompt-based",
    output: "Table",
    prompt: "List design sprint artifacts and recent updates.",
    spec: buildSpec({
      id: "enterprise-design-sprint-insights",
      name: "Design Sprint Asset Tracker",
      description: "Track design sprint assets.",
      purpose: "Find design sprint artifacts across Notion and Drive.",
      integrations: ["notion", "google"],
      entities: [notionPageEntity, driveFileEntity],
      actions: [
        {
          id: "notion.design.search",
          name: "Search design pages",
          description: "Fetch design sprint pages",
          type: "READ",
          integrationId: "notion",
          capabilityId: "notion_pages_search",
          inputSchema: { query: "string" },
          outputSchema: { pages: "array" },
          writesToState: false,
        },
        {
          id: "google.drive.design",
          name: "List design assets",
          description: "Fetch design assets from Drive",
          type: "READ",
          integrationId: "google",
          capabilityId: "google_drive_list",
          inputSchema: { query: "string" },
          outputSchema: { files: "array" },
          writesToState: false,
        },
      ],
      views: [
        {
          id: "design-notion-table",
          name: "Design Pages",
          type: "table",
          source: { entity: "Page", statePath: "notion.design_pages" },
          fields: ["title", "lastEdited", "url"],
          actions: ["notion.design.search"],
        },
        {
          id: "design-drive-table",
          name: "Drive Assets",
          type: "table",
          source: { entity: "File", statePath: "google.design_assets" },
          fields: ["name", "modifiedTime", "webViewLink"],
          actions: ["google.drive.design"],
        },
      ],
      query_plans: [
        {
          integrationId: "notion",
          actionId: "notion.design.search",
          query: { query: "design sprint OR UX" },
          fields: ["title", "lastEdited", "url"],
          max_results: 10,
        },
        {
          integrationId: "google",
          actionId: "google.drive.design",
          query: { q: "name contains 'Design' or name contains 'Sprint'" },
          fields: ["name", "modifiedTime", "webViewLink"],
          max_results: 15,
        },
      ],
      answer_contract: {
        entity_type: "page",
        required_constraints: [{ field: "title", operator: "semantic_contains", value: "Design" }],
        failure_policy: "empty_over_incorrect",
        list_shape: "array",
      },
      goal_plan: {
        kind: "DATA_RETRIEVAL",
        primary_goal: "Track design sprint assets",
        sub_goals: ["List Notion sprint pages", "List Drive assets"],
        constraints: ["Most recent first"],
        derived_entities: [],
      },
      intent_contract: buildIntentContract({
        userGoal: "Design sprint assets",
        integrations: ["notion", "google"],
        objects: ["Page", "File"],
        filters: ["design sprint", "ux"],
        successCriteria: ["Design artifacts returned"],
        forbiddenOutputs: ["dummy", "mock", "placeholder"],
      }),
      dataReadiness: { requiredEntities: ["Page", "File"], minimumRecords: 1 },
    }),
  },
];

export const useCaseCategories: UseCaseCategory[] = [
  "Featured",
  "Engineering",
  "Design",
  "Marketing",
  "Sales",
  "Operations",
  "Leadership / Exec",
  "Personal (Consumer)",
];

export const useCasesByCategory = useCaseCategories.map((category) => ({
  category,
  items: useCases.filter((tool) => tool.category === category),
}));

export { useCases };
